---
_DATATYPES:
  _dtword: &dtword
    _parse: 'scalar'
    _type:  'word'
  _dtstring: &dtstring
    _parse: 'scalar'
    _type:  'string'
  _dtdate: &dtdate
    _parse: 'scalar'
    _type:  'date'
  _dtfloat: &dtfloat
    _parse: 'scalar'
    _type:  'float'
  _dtdouble: &dtdouble
    _parse: 'scalar'
    _type:  'double'
  _dtdblnamed: &dtdblnamed
    _parse: 'scalar'
    _type:  'double'
    _named: 1
  _dtint: &dtint
    _parse: 'scalar'
    _type:  'int'
  _dtbool: &dtbool
    _parse: 'scalar'
    _type:  'word'
  _dtlist: &dtlist
    _parse: 'list'
    _named: 0
  _dtlistnamed: &dtlistnamed
    _parse: 'list'
    _named: 1
  _dtblock: &dtblock
    _parse: 'block'
    _named: 0
  _dtblocknamed: &dtblocknamed
    _parse: 'block'
    _named: 1

_DIRECTORY:
  CASEID:
  STATE:
  CORE:
  ASSEMBLY:
  CONTROL:
  INSERT:
  DETECTOR:
  EDITS:
  SHIFT:
  COBRATF:
  COUPLING:
  MPACT:
  BISON:
  MAMBA:
  TIAMAT:
  RUN:

#>
#> \section{Block CASEID}
#> \label{sec:caseidcards}
CASEID:
#>
#>   {\bf title} case\_name
#>   \VERAInputTable{
#>     name={title},
#>     type={Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Problem name},
#>     notes={}
#>   }
  title:
    <<: *dtstring
    _content: default
    _check:
      - is_string()
#>
#> \section{Block STATE}
#> \label{sec:statecards}
STATE:
  <<: *dtblocknamed
  id:
    <<: *dtstring
    _content:
    _check:
      - is_string()
#>
#>   {\bf title} state\_name
#>   \VERAInputTable{
#>     name={title},
#>     type={Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={},
#>     limitations={},
#>     description={State name},
#>     notes={}
#>   }
  title:
    <<: *dtstring
    _content:
    _check:
      - is_string()
#>
#>   {\bf op\_date} op\_date
#>   \VERAInputTable{
#>     name={op\_date},
#>     type={Character String (``MM/DD/YYYY'' or ``YYYY/MM/DD'')},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Operating date of this statepoint.  Used when writing restart files.},
#>     notes={}
#>   }
  op_date:
    <<: *dtdate
    _content:
    _check:
      - is_string()
#>
#>   {\bf power} power
#>   \VERAInputTable{
#>     name={power},
#>     type={Float},
#>     need={Optional},
#>     unitsdefault={Percent of rated power},
#>     unitsother={},
#>     valuedefault={1e-8},
#>     valuesapplicable={$>=0$},
#>     limitations={},
#>     description={Operating power},
#>     notes={}
#>   }
  power:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_geq() 0
#>
#>   {\bf flow} flow
#>   \VERAInputTable{
#>     name={flow},
#>     type={Float},
#>     need={Optional},
#>     unitsdefault={Percent of rated flow},
#>     unitsother={},
#>     valuedefault={1e-8},
#>     valuesapplicable={$>=0$},
#>     limitations={},
#>     description={Operating flow},
#>     notes={}
#>   }
  flow:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_geq() 0
#>
#>   {\bf flow\_dist} flow\_dist
#>   \VERAInputTable{
#>     name={flow\_dist},
#>     type={2D Float Map},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={2-D array that must match the shape of assm\_map in [CORE].  Gives a multiplier that will be applied to nominal flow in each assembly.}},
#>     notes={}
#>   }
  flow_dist:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_word(shift)},())
      - fall(sub{is_float(shift)},())
      - fall(sub{not_in_dictionary(shift,'_EMPTY_')},())
#>
#>   {\bf bypass} bypass
#>   \VERAInputTable{
#>     name={bypass},
#>     type={Float},
#>     need={Optional},
#>     unitsdefault={Percent of flow},
#>     unitsother={},
#>     valuedefault={0},
#>     valuesapplicable={$>=0$},
#>     limitations={},
#>     description={Bypass flow fraction \hl{current manual says rated flow}},
#>     notes={}
#>   }
  bypass:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_geq() 0
#>
#>   {\bf bypass} bypass
#>   \VERAInputTable{
#>     name={bypass},
#>     type={Float},
#>     need={Optional},
#>     unitsdefault={Percent of flow},
#>     unitsother={},
#>     valuedefault={0},
#>     valuesapplicable={$>=0$},
#>     limitations={},
#>     description={Bypass flow fraction \hl{current manual says rated flow}},
#>     notes={}
#>   }
  tinlet:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==2
      - is_float(nth(0,()))
      - is_word(nth(1,()))
      - in_dictionary(nth(1,()),'F','C','K')
#>
#>   {\bf tinlet_dist} tinlet_dist
#>   \VERAInputTable{
#>     name={tinlet\_dist},
#>     type={2D Float Map},
#>     need={Optional},
#>     unitsdefault={F},
#>     unitsother={},
#>     valuedefault={0},
#>     valuesapplicable={},
#>     limitations={},
#>     description={2-D array that must match the shape of assm\_map in [CORE].  Gives an adder that will be applied to nominal inlet temperature in each assembly.}},
#>     notes={}
#>   }
  tinlet_dist:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_word(shift)},())
      - fall(sub{is_float(shift)},())
      - fall(sub{not_in_dictionary(shift,'_EMPTY_')},())
  void:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_word(shift)},())
      - fall(sub{is_float(shift)},())
      - fall(sub{not_in_dictionary(shift,'_EMPTY_')},())
  tfuel:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==2
      - is_float(nth(0,()))
      - is_word(nth(1,()))
      - in_dictionary(nth(1,()),'F','C','K')
  modden:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  xenon:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() zero dep equil
  samar:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() zero dep equil peak
  rlx_xesm:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
      - is_leq() 1.0
  pred_order:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_geq() 0
  corr_order:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_geq() 0
  boron:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_geq() 0
  b10:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==2
      - is_float(nth(0,()))
      - is_word(nth(1,()))
      - nth(0,())>=0
  kcrit:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_geq() 0
  search:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() keff boron rod
  search_bank:
    <<: *dtword
    _content:
    _check:
      - is_word()
  pressure:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  deplete:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_float(shift)},stride(1,1,()))
      - nth(0,())eq"GWDMT"||nth(0,())eq"MWDMT"||nth(0,())eq"EFPD"||nth(0,())eq"hours"
      - is_strictlyincreasing(stride(1,1,()))
  edit:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
  reset_sol:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false

  rodbank:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_word(shift)},())
      - fall(sub{is_float(shift)},odd([]))
      - fall(sub{is_geq(shift,0)},odd([]))
  feedback:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() on off
  fuel_performance:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() on off inline
  crud:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() on off
  excore_transport:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() on off
  thexp:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() on off
  thexp_tfuel:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==2
      - is_float(nth(0,()))
      - is_word(nth(1,()))
      - in_dictionary(nth(1,()),'F','C','K')
  thexp_tclad:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==2
      - is_float(nth(0,()))
      - is_word(nth(1,()))
      - in_dictionary(nth(1,()),'F','C','K')
  thexp_tmod:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==2
      - is_float(nth(0,()))
      - is_word(nth(1,()))
      - in_dictionary(nth(1,()),'F','C','K')
  expand3D:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
  thexp_outfile:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  thexp_info:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
  apitch_tec:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
  ppitch_tec:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
  sym:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() full qtr
  kmul_beta:
    <<: *dtdouble
    _content:
    _check:
      - is_gt() 0
      - is_leq()  1

  kmul_doppler:
    <<: *dtdouble
    _content:
    _check:
      - is_gt() 0
      - is_leq() 1
  kmul_modtemp:
    <<: *dtdouble
    _content:
    _check:
      - is_gt() 0
      - is_leq() 1

  kmul_crw:
    <<: *dtdouble
    _content:
    _check:
      - is_gt() 0
      - is_leq() 100

  scram_type:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - is_word(nth(0,()))
      - fall(sub{is_float(shift)},stride(1,2,()))
      - fall(sub{is_geq(shift,0)},stride(1,2,()))
      - fall(sub{is_float(shift)},stride(2,2,()))
      - fall(sub{is_gt(shift,0)},stride(2,2,()))
      - arraysize()%2!=0
  bank_wd:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - is_word(nth(0,()))
      - fall(sub{is_float(shift)},stride(1,2,()))
      - fall(sub{is_geq(shift,0)},stride(1,2,()))
      - fall(sub{is_int(shift)},stride(2,2,()))
      - fall(sub{is_gt(shift,0)},stride(2,2,()))
      - arraysize()%2==1
  scram_lock:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_word(shift)},())
  trip_time:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  trip_power:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==4
      - is_float(nth(0,()))&&nth(0,())>0
      - is_float(nth(1,()))&&nth(1,())>=0
      - is_float(nth(2,()))&&nth(2,())>=0
      - (is_int(nth(3,()))||nth(3,())==0)&&nth(3,())>=0
  trip_rate:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==4
      - is_float(nth(0,()))
      - is_float(nth(1,()))
      - is_float(nth(2,()))&&nth(2,())>=0
      - (is_int(nth(3,()))||nth(3,())==0)&&nth(3,())>=0

  restart_shuffle:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_word(shift)},())
  restart_read:
    <<: *dtlist
    _content:
    _check:
      - fall(sub{is_word(shift)},())
      - arraysize()==2
  restart_write:
    <<: *dtlist
    _content:
    _check:
      - fall(sub{is_word(shift)},())
      - arraysize()==2
  shuffle_label:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_word(shift)},())
      - fall(sub{not_in_dictionary(shift,'0')},())
  insert_shuffle_label:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_word(shift)},())
      - fall(sub{not_in_dictionary(shift,'0')},())
  shuffle_homog:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() none center all
  crud_cleaning:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_word(shift)},())
      - fall(sub{not_in_dictionary(shift,'0')},())
  crud_removal:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_geq() 0
  cool_chem:
    <<: *dtlist
    _content:
    _check:
      - fall(sub{is_float(shift)},())
      - arraysize()==5
      - nth(0,())>=0
      - nth(1,())>=0
      - nth(2,())>=0
      - nth(3,())>=0
      - nth(4,())>=0
  vh2:
    <<: *dtfloat
    _content:
    _check:
      - is_float()
      - is_geq() 0
  ni_s:
    <<: *dtfloat
    _content:
    _check:
      - is_float()
      - is_geq() 0
  ni_p:
    <<: *dtfloat
    _content:
    _check:
      - is_float()
      - is_geq() 0
  cleanup_flow:
    <<: *dtfloat
    _content:
    _check:
      - is_float()
      - is_geq() 0
      - is_leq() 100
  temp_pert:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==2
      - is_float(nth(0,()))
      - is_float(nth(1,()))

CORE:
  name:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  cycle:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  unit:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  op_date:
    <<: *dtdate
    _content:
    _check:
      - is_string()
  size:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
  rated:
    <<: *dtlist
    _content:
    _check:
      - fall(sub{is_float(shift)},())
      - arraysize()==2
      - nth(0,())>=0
      - nth(1,())>=0
  rcs_volume:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  apitch:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  baffle:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==3
      - is_word(nth(0,()))
      - is_float(nth(1,()))
      - is_float(nth(2,()))
      - nth(1,())>=0
      - nth(2,())>=0
  pad:
    <<: *dtlist
    _content:
    _check:
      - is_word(nth(0,()))
      - is_float(nth(1,()))
      - is_float(nth(2,()))
      - nth(1,())>=0
      - nth(2,())>=0
  pad_nonuniform_arc:
    <<: *dtlist
    _content:
    _check:
  vessel:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - arraysize()%2==0
      - fall(sub{is_string(shift)},stride(0,2,()))
      - fall(sub{is_float(shift)},stride(1,2,()))
      - fall(sub{is_geq(shift,0)},stride(1,2,()))
  hole:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - arraysize()%3==0
      - fall(sub{is_float(shift)},stride(0,3,()))
      - fall(sub{is_float(shift)},stride(1,3,()))
      - fall(sub{is_float(shift)},stride(2,3,()))
  core_shape:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_int(shift)},())
      - fall(sub{is_geq(shift,0)},())
      - fall(sub{is_leq(shift,1)},())
  assm_map:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_word(shift)},())
      - fall(sub{not_in_dictionary(shift,'0')},())
      - fall(sub{not_in_dictionary(shift,'_EMPTY_')},())
  rotate_map:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_int(shift)},())
      - fall(sub{is_geq(shift,0)},())
      - fall(sub{is_leq(shift,3)},())
      - fall(sub{not_in_dictionary(shift,'_EMPTY_')},())
  insert_rotate_map:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_int(shift)},())
      - fall(sub{is_geq(shift,0)},())
      - fall(sub{is_leq(shift,3)},())
      - fall(sub{not_in_dictionary(shift,'_EMPTY_')},())
  insert_map:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_word(shift)},())
      - fall(sub{not_in_dictionary(shift,'0')},())
      - fall(sub{not_in_dictionary(shift,'_EMPTY_')},())
  det_map:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_word(shift)},())
      - fall(sub{not_in_dictionary(shift,'0')},())
      - fall(sub{not_in_dictionary(shift,'_EMPTY_')},())
  crd_map:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_word(shift)},())
      - fall(sub{not_in_dictionary(shift,'0')},())
      - fall(sub{not_in_dictionary(shift,'_EMPTY_')},())
  crd_bank:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_word(shift)},())
      - fall(sub{not_in_dictionary(shift,'0')},())
      - fall(sub{not_in_dictionary(shift,'_EMPTY_')},())
  lower_plate:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==3
      - is_word(nth(0,()))
      - is_float(nth(1,()))
      - is_float(nth(2,()))
      - nth(1,())>=0
      - nth(2,())>=0
      - nth(2,())<=1
  upper_plate:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==3
      - is_word(nth(0,()))
      - is_float(nth(1,()))
      - is_float(nth(2,()))
      - nth(1,())>=0
      - nth(2,())>=0
      - nth(2,())<=1
  bc_sym:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() rot mir
  bc_bot:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() reflecting vacuum
  bc_top:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() reflecting vacuum
  bc_rad:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() reflecting vacuum
  xlabel:
    <<: *dtlist
    _content:
    _check:
      - fall(sub{is_word(shift)},())
  ylabel:
    <<: *dtlist
    _content:
    _check:
      - fall(sub{is_word(shift)},())
  label_format:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() x-y y-x .x-y .y-x
  height:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_geq() 0
  mat:
    <<: *dtlistnamed
    _style: multi-line
    _slash:
    _check:
      - arraysize()>1
      - nth(1,())>=0
      - lc(nth(0,()))ne'mod'
    _options:
      thexp: double
      thcnd: double
    _defaults:
      _path: CORE/%(_keyword)/$(_id)

  lower_ref:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - arraysize()%3==0
      - fall(sub{is_string(shift)},stride(0,3,()))
      - fall(sub{is_float(shift)},stride(1,3,()))
      - fall(sub{is_geq(shift,0)},stride(1,3,()))
      - fall(sub{is_float(shift)},stride(2,3,()))
      - fall(sub{is_geq(shift,0)},stride(2,3,()))
      - fall(sub{is_leq(shift,1)},stride(2,3,()))
  upper_ref:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - arraysize()%3==0
      - fall(sub{is_string(shift)},stride(0,3,()))
      - fall(sub{is_float(shift)},stride(1,3,()))
      - fall(sub{is_geq(shift,0)},stride(1,3,()))
      - fall(sub{is_float(shift)},stride(2,3,()))
      - fall(sub{is_geq(shift,0)},stride(2,3,()))
      - fall(sub{is_leq(shift,1)},stride(2,3,()))

  reactor_type:
    <<: *dtstring
    _content:
    _check:
      - is_word()
      - in_dictionary() BWR PWR

  source:
    <<: *dtlistnamed
    _style: multi-line
    _slash:
    _check:
      - arraysize()>1
    _defaults:
      _path: CORE/%(_keyword)/$(_id)

  steam_generator:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==4
      - is_word(nth(0,()))
      - is_int(nth(1,()))
      - is_float(nth(2,()))
      - is_float(nth(3,()))
      - nth(0,())eq'oncethrough'||nth(0,())eq'utube'
      - nth(1,())==600||nth(1,())==690||nth(1,())==800||nth(1,())==304
      - nth(2,())>=0
      - nth(3,())>=0&&nth(3,())<=1

  hot_leg_piping:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==2
      - is_int(nth(0,()))
      - is_float(nth(1,()))
      - nth(0,())==600||nth(0,())==690||nth(0,())==800||nth(0,())==304
      - nth(1,())>=0

  cold_leg_piping:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==2
      - is_int(nth(0,()))
      - is_float(nth(1,()))
      - nth(0,())==600||nth(0,())==690||nth(0,())==800||nth(0,())==304
      - nth(1,())>=0

  cleanup_rated_flow:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_geq() 0

ASSEMBLY:
  <<: *dtblocknamed
  title:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  npin:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
  ppitch:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  cell:
    <<: *dtlistnamed
    _slash:
    _check:
  lattice:
    <<: *dtlistnamed
    _style: multi-line
    _check:
      - fall(sub{is_word(shift)},())
      - fall(sub{not_in_dictionary(shift,'0')},stride(1,1,()))
    _alias: rodmap
  rodmap:
    <<: *dtlistnamed
    _style: multi-line
    _check:
      - fall(sub{is_word(shift)},())
      - fall(sub{not_in_dictionary(shift,'0')},stride(1,1,()))
  axial:
    <<: *dtlistnamed
    _style: multi-line
    _check:
      - fall(sub{is_geq(shift,0)},stride(1,2,()))
      - is_strictlyincreasing(stride(1,2,()))
  grid:
    <<: *dtlistnamed
    _style:
    _check:
      - nth(2,())>0
      - arraysize()==4
    _parameters:
      loss:
        <<: *dtdouble
        _check:
          - is_float()
          - is_geq() 0
      blockage:
        <<: *dtdouble
        _check:
          - is_float()
          - is_geq() 0
      gridmap:
        <<: *dtstring
        _check:
          - is_string()

  grid_axial:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_float(shift)},odd([]))
  lower_nozzle:
    <<: *dtlist
    _content:
    _check:
      - nth(1,())>0
      - nth(2,())>0
  upper_nozzle:
    <<: *dtlist
    _content:
    _check:
      - nth(1,())>0
      - nth(2,())>0
  fuel:
    <<: *dtlistnamed
    _style: multi-line
    _slash:
    _check:
      - nth(1,())>=0
      - nth(2,())eq'/'||nth(3,())eq'/'||nth(4,())eq'/'
      - (nth(2,())eq'/'&&(nth(3,())>=0))||(nth(3,())eq'/'&&(nth(4,())>=0))||(nth(4,())eq'/'&&(nth(5,())>=0))
    _options:
      form: string
      thexp: double

  mat:
    <<: *dtlistnamed
    _style: multi-line
    _slash:
    _check:
      - arraysize()>1
      - nth(1,())>=0
      - lc(nth(0,()))ne'mod'
    _options:
      thexp: double
      thcnd: double
    _defaults:
      _path: CORE/%(_keyword)/$(_id)

  gap:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==2
      - nth(0,())>=0
      - nth(1,())>=0

  channel_box:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==5
      - is_string(nth(0,()))
      - nth(1,())>=0
      - nth(2,())>=0
      - nth(3,())>=0
      - nth(4,())>=0

  temptable:
    <<: *dtlistnamed
    _style: multi-line
    _check:
      - arraysize()>1
      - arraysize()%3==0
      - is_word(nth(0,()))
      - is_word(nth(1,()))
      - nth(1,())eq'temptable_boundary'
      - is_word(nth(3,()))
      - nth(3,())eq'temptable_qprime'
      - is_float(nth(4,()))
      - nth(5,())eq'temptable_polynomial'
      - fall(sub{is_float(shift)},stride(6,1,()))

CONTROL:
  <<: *dtblocknamed
  _maxid: 1
  title:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  npin:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
  stroke:
    <<: *dtlist
    _content:
    _check:
      - is_float(nth(0,()))
      - is_float(nth(1,()))
  cell:
    <<: *dtlistnamed
    _slash:
    _check:
  lattice:
    <<: *dtlistnamed
    _style: multi-line
    _check:
      - fall(sub{is_word(shift)},())
      - fall(sub{not_in_dictionary(shift,'0')},stride(1,1,()))
    _alias: rodmap
  rodmap:
    <<: *dtlistnamed
    _style: multi-line
    _check:
      - fall(sub{is_word(shift)},())
      - fall(sub{not_in_dictionary(shift,'0')},stride(1,1,()))
  axial:
    <<: *dtlistnamed
    _style: multi-line
    _check:
      - fall(sub{is_geq(shift,0)},stride(1,2,()))
  mat:
    <<: *dtlistnamed
    _style: multi-line
    _slash:
    _check:
      - arraysize()>1
      - nth(1,())>=0
      - lc(nth(0,()))ne'mod'
    _options:
      thexp: double
      thcnd: double
    _defaults:
      _path: CORE/%(_keyword)/$(_id)

  blade:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==8
      - nth(0,())>0
      - is_string(nth(1,()))
      - nth(2,())>0
      - nth(3,())>0
      - nth(4,())>0
      - nth(5,())>0
      - nth(6,())>0
      - is_string(nth(7,()))

INSERT:
  <<: *dtblocknamed
  title:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  npin:
    <<: *dtint
    _content:
    _check:
      - is_int()
  cell:
    <<: *dtlistnamed
    _slash:
    _check:
  lattice:
    <<: *dtlistnamed
    _style: multi-line
    _check:
      - fall(sub{is_word(shift)},())
      - fall(sub{not_in_dictionary(shift,'0')},stride(1,1,()))
    _alias: rodmap
  rodmap:
    <<: *dtlistnamed
    _style: multi-line
    _check:
      - fall(sub{is_word(shift)},())
      - fall(sub{not_in_dictionary(shift,'0')},stride(1,1,()))
  axial:
    <<: *dtlistnamed
    _style: multi-line
    _check:
      - fall(sub{is_geq(shift,0)},stride(1,2,()))
  mat:
    <<: *dtlistnamed
    _style: multi-line
    _slash:
    _check:
      - arraysize()>1
      - nth(1,())>=0
      - lc(nth(0,()))ne'mod'
    _options:
      thexp: double
      thcnd: double
    _defaults:
      _path: CORE/%(_keyword)/$(_id)

DETECTOR:
  <<: *dtblocknamed
  _maxid: 1
  title:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  type:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() u235 v rh
  npin:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
  cell:
    <<: *dtlistnamed
    _slash:
    _check:
  lattice:
    <<: *dtlistnamed
    _style: multi-line
    _check:
      - fall(sub{is_word(shift)},())
      - fall(sub{not_in_dictionary(shift,'0')},stride(1,1,()))
    _alias: rodmap
  rodmap:
    <<: *dtlistnamed
    _style: multi-line
    _check:
      - fall(sub{is_word(shift)},())
      - fall(sub{not_in_dictionary(shift,'0')},stride(1,1,()))
  axial:
    <<: *dtlistnamed
    _style: multi-line
    _check:
      - fall(sub{is_geq(shift,0)},stride(1,2,()))
  mat:
    <<: *dtlistnamed
    _style: multi-line
    _slash:
    _check:
      - arraysize()>1
      - nth(1,())>=0
      - lc(nth(0,()))ne'mod'
    _options:
      thexp: double
      thcnd: double
    _defaults:
      _path: CORE/%(_keyword)/$(_id)

EDITS:
  axial_edit_bounds:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_float(shift)},())
  axial_edit_mesh_delta:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
  points:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - arraysize()%4==0
      - fall(sub{is_string(shift)},stride(0,4,()))
      - fall(sub{is_float(shift)},stride(1,4,()))
      - fall(sub{is_float(shift)},stride(2,4,()))
      - fall(sub{is_float(shift)},stride(3,4,()))
  edit_group:
    <<: *dtlistnamed
    _style: multi-line
    _content:
    _check:

#>
#> \section{Block SHIFT}
#> \label{sec:shiftcards}
SHIFT:
#>
#>   {\bf ce\_lib\_path} ce\_lib\_path
#>   \VERAInputTable{
#>     name={ce\_lib\_path},
#>     type={String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={ce_v7.1\_endf.h5},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Path to SCALE CE data library file},
#>     notes={}
#>   }
  ce_lib_path:
    <<: *dtword
    _content:
    _check:
      - is_word()
#>
#>   {\bf transfer} transfer
#>   \VERAInputTable{
#>     name={transfer},
#>     type={String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={Depends on coupling},
#>     valuesapplicable={all, fiss\_src, isotopics, temps},
#>     limitations={},
#>     description={What to transfer with VERA-CS},
#>     notes={}
#>   }
  transfer:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() all fiss_src isotopics temps
#>
#>   {\bf temp\_transfer} temp\_transfer
#>   \VERAInputTable{
#>     name={temp\_transfer},
#>     type={String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={all},
#>     valuesapplicable={all, none, pin},
#>     limitations={},
#>     description={Which temperatures to couple with CTF},
#>     notes={}
#>   }
  temp_transfer:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() all none pin

#>
#>   {\bf verbosity} verbosity
#>   \VERAInputTable{
#>     name={verbosity},
#>     type={string},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={none},
#>     valuesapplicable={none, low, medium, high},
#>     limitations={},
#>     description={How often to print about particles being transported},
#>     notes={}
#>   }
  verbosity:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() none low medium high
#>
#>   {\bf broaden\_xs} broaden\_xs
#>   \VERAInputTable{
#>     name={broaden\_xs},
#>     type={bool},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={true},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Cross-section doppler broadening for temperature},
#>     notes={}
#>   }
  broaden_xs:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf temperature\_tol} temperature\_tol
#>   \VERAInputTable{
#>     name={temperature\_tol},
#>     type={double},
#>     need={Optional},
#>     unitsdefault={K},
#>     unitsother={},
#>     valuedefault={4.0},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Tolerance for reusing existing broadened cross sections},
#>     notes={}
#>   }
  temperature_tol:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
#>
#>   {\bf union\_energy} union\_energy
#>   \VERAInputTable{
#>     name={union\_energy},
#>     type={bool},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={true},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Unionize lower and upper library temperature energy grids},
#>     notes={}
#>   }
  union_energy:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf delta_\t} delta\_t
#>   \VERAInputTable{
#>     name={delta\_t},
#>     type={double},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1.0},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Finite difference grid spacing for Leal-Hwang temperature interpolation of cross sections},
#>     notes={}
#>   }
  delta_t:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
#>
#>   {\bf energy\_tol} energy\_tol
#>   \VERAInputTable{
#>     name={energy\_tol},
#>     type={double},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1.0E-10},
#>     valuesapplicable={(0,1)},
#>     limitations={},
#>     description={Relative difference for considering two energy points equal},
#>     notes={}
#>   }
  energy_tol:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
      - is_lt() 1
#>
#>   {\bf dbrc} dbrc
#>   \VERAInputTable{
#>     name={dbrc},
#>     type={bool},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={false},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Apply doppler broadening resonance correction},
#>     notes={}
#>   }
  dbrc:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf global\_log} global\_log
#>   \VERAInputTable{
#>     name={global\_log},
#>     type={string},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={info},
#>     valuesapplicable={debug, diagnostic, status, info, warning, error, critical},
#>     limitations={},
#>     description={Level of global log information},
#>     notes={}
#>   }
  global_log:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() debug diagnostic status info warning error critical
#>
#>   {\bf local\_log} local\_log
#>   \VERAInputTable{
#>     name={local\_log},
#>     type={string},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={error},
#>     valuesapplicable={debug, diagnostic, status, info, warning, error, critical},
#>     limitations={},
#>     description={Level of local node log information},
#>     notes={}
#>   }
  local_log:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() debug diagnostic status info warning error critical
#>
#>   {\bf do\_micro\_tally} do\_micro\_tally
#>   \VERAInputTable{
#>     name={do\_micro\_tally},
#>     type={bool},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={false},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Tally micro reactions in eigenvalue mode},
#>     notes={Eigenvalue mode only}
#>   }
  do_micro_tally:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf do\_transport} do\_transport
#>   \VERAInputTable{
#>     name={do\_transport},
#>     type={bool},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={true},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Perform MC transport},
#>     notes={}
#>   }
  do_transport:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf do\_output} do\_output
#>   \VERAInputTable{
#>     name={do\_output},
#>     type={bool},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={true},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Do Shift output},
#>     notes={}
#>   }
  do_output:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf micro\_zaids} micro\_zaids
#>   \VERAInputTable{
#>     name={micro\_zaids},
#>     type={Array of integers},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={92235, 92238},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Nuclides to tally micro reactions in eigenvalue mode},
#>     notes={Eigenvalue mode only}
#>   }
  micro_zaids:
    <<: *dtlist
    _content:
    _check:
#>
#>   {\bf micro\_rxns} micro\_rxns
#>   \VERAInputTable{
#>     name={micro\_rxns},
#>     type={Array of integers},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={18, 102},
#>     valuesapplicable={},
#>     limitations={},
#>     description={MT of micro reactions to tally in eigenvalue mode},
#>     notes={Eigenvalue mode only}
#>   }
  micro_rxns:
    <<: *dtlist
    _content:
    _check:
#>
#>   {\bf gamma\_flux} gamma\_flux
#>   \VERAInputTable{
#>     name={gamma\_flux},
#>     type={bool},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={false},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Tally the photon flux in each pincell},
#>     notes={}
#>   }
  gamma_flux:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf lost\_particle\_error\_tol} lost\_particle\_error\_tol
#>   \VERAInputTable{
#>     name={lost\_particle\_error\_tol},
#>     type={double},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1E-06},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Fraction of lost particles to tolerate before aborting},
#>     notes={}
#>   }
  lost_particle_error_tol:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
#>
#>   {\bf num\_cycles} num\_cycles
#>   \VERAInputTable{
#>     name={num\_cycles},
#>     type={integer},
#>     need={},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={50},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Number of eigenvalue cycles},
#>     notes={}
#>   }
  num_cycles:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf num\_inactive\_cycles} num\_inactive\_cycles
#>   \VERAInputTable{
#>     name={num\_inactive\_cycles},
#>     type={integer},
#>     need={},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={10},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Number of inactive eigenvalue cycles},
#>     notes={}
#>   }
  num_inactive_cycles:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf Np} Np
#>   \VERAInputTable{
#>     name={Np},
#>     type={double},
#>     need={},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1000},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Number of particles to transport},
#>     notes={}
#>   }
  Np:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
#>
#>   {\bf transport} transport
#>   \VERAInputTable{
#>     name={transport},
#>     type={string},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={ce},
#>     valuesapplicable={ce, mg},
#>     limitations={},
#>     description={Type of physics},
#>     notes={}
#>   }
  transport:
    <<: *dtstring
    _content:
    _check:
      - is_word()
      - in_dictionary() ce mg
#>
#>   {\bf problem\_mode} problem\_mode
#>   \VERAInputTable{
#>     name={problem\_mode},
#>     type={string},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={eigenvalue},
#>     valuesapplicable={cadis, eigenvalue, forward},
#>     limitations={},
#>     description={Run mode},
#>     notes={}
#>   }
  problem_mode:
    <<: *dtstring
    _content:
    _check:
      - is_word()
      - in_dictionary() cadis eigenvalue forward
#>
#>   {\bf mode} mode
#>   \VERAInputTable{
#>     name={mode},
#>     type={string},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={n (eigenvalue), np (forward)},
#>     valuesapplicable={n, np},
#>     limitations={},
#>     description={Type of particles to transport},
#>     notes={}
#>   }
  mode:
    <<: *dtstring
    _content:
    _check:
      - is_word()
      - in_dictionary() n np
#>
#>   {\bf output\_geometry} output\_geometry
#>   \VERAInputTable{
#>     name={output\_geometry},
#>     type={bool},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={true},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Output HDF5 files of raytraced geometry (initial) and compositions (each state)},
#>     notes={}
#>   }
  output_geometry:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf output\_fission\_source} output\_fission\_source
#>   \VERAInputTable{
#>     name={output\_fission\_source},
#>     type={bool},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={false},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Output the initial fission source for each state},
#>     notes={}
#>   }
  output_fission_source:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf output\_micro\_tally} output\_micro\_tally
#>   \VERAInputTable{
#>     name={output\_micro\_tally},
#>     type={bool},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={false},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Output micro reaction tallies},
#>     notes={}
#>   }
  output_micro_tally:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf output\_ww} output\_ww
#>   \VERAInputTable{
#>     name={output\_ww},
#>     type={bool},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={false},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Output the weight windows, if used},
#>     notes={}
#>   }
  output_ww:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf thermal\_energy\_cutoff} thermal\_energy\_cutoff
#>   \VERAInputTable{
#>     name={thermal\_energy\_cutoff},
#>     type={double},
#>     need={Optional},
#>     unitsdefault={eV},
#>     unitsother={},
#>     valuedefault={10.0},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Cutoff for treatment of thermal neutrons},
#>     notes={}
#>   }
  thermal_energy_cutoff:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
#>
#>   {\bf excore\_filename} excore\_filename
#>   \VERAInputTable{
#>     name={excore\_filename},
#>     type={string},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Name of Omnibus XML file with excore features and tallies},
#>     notes={}
#>   }
  excore_filename:
    <<: *dtword
    _content:
    _check:
     - is_word()
#>
#>   {\bf raytrace\_levels} raytrace\_levels
#>   \VERAInputTable{
#>     name={raytrace\_levels},
#>     type={array of doubles},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={midpoint of active fuel},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Z levels to raytrace geometry and output},
#>     notes={}
#>   }
  raytrace_levels:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
#>
#>   {\bf raytrace\_resolution} raytrace\_resolution
#>   \VERAInputTable{
#>     name={raytrace\_resolution},
#>     type={integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1024},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Resolution for geometry raytrace},
#>     notes={}
#>   }
  raytrace_resolution:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf vera_pressure_vessel} vera_pressure_vessel
#>   \VERAInputTable{
#>     name={vera_pressure_vessel},
#>     type={bool},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={false},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Pull in the pressure vessel from the VERA geometry},
#>     notes={Applicable to excore only}
#>   }
  vera_pressure_vessel:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf use_mpact_spectrum} use_mpact_spectrum
#>   \VERAInputTable{
#>     name={use_mpact_spectrum},
#>     type={bool},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={false},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Use the fission source spectrum provided by MPACT},
#>     notes={}
#>   }
  use_mpact_spectrum:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf hybrid\_tally\_names} hybrid\_tally\_names
#>   \VERAInputTable{
#>     name={hybrid\_tally\_names},
#>     type={array of strings},
#>     need={Required if problem mode is CADIS},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Excore tally name to optimize for CADIS},
#>     notes={Applicable to hybrid simulations}
#>   }
  hybrid_tally_names:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
#>
#>   {\bf hybrid\_multiplier\_names} hybrid\_multiplier\_names
#>   \VERAInputTable{
#>     name={hybrid\_multiplier\_names},
#>     type={array of strings},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Excore tally multipliers to optimize for CADIS},
#>     notes={Applicable to hybrid simulations}
#>   }
  hybrid_multiplier_names:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
#>
#>   {\bf src\_disc\_l2\_error} src\_disc\_l2\_error
#>   \VERAInputTable{
#>     name={src\_disc\_l2\_error},
#>     type={double},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={0.01},
#>     valuesapplicable={(0,1)},
#>     limitations={},
#>     description={Maximum L2 error for point-sampling discretization},
#>     notes={Applicable to hybrid simulations}
#>   }
  src_disc_l2_error:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
      - is_lt() 1
#>
#>   {\bf src\_disc\_samples\_per\_batch} src\_disc\_samples\_per\_batch
#>   \VERAInputTable{
#>     name={src\_disc\_samples\_per\_batch},
#>     type={integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1E05},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Number of sammples per point-sampling batch},
#>     notes={Applicable to hybrid simulations}
#>   }
  src_disc_samples_per_batch:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf src\_disc\_max\_samples} src\_disc\_max\_samples
#>   \VERAInputTable{
#>     name={src\_disc\_max\_samples},
#>     type={integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1E10},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Maximum number of discretization samples},
#>     notes={Applicable to hybrid simulations}
#>   }
  src_disc_max_samples:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf ww\_decomp} ww\_decomp
#>   \VERAInputTable{
#>     name={ww\_decomp},
#>     type={string},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={separable},
#>     valuesapplicable={full, separable},
#>     limitations={},
#>     description={Whether the weight window adjoint flux should be decomposed},
#>     notes={Applicable to hybrid simulations}
#>   }
  ww_decomp:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() full separable
#>
#>   {\bf radial\_mesh} radial\_mesh
#>   \VERAInputTable{
#>     name={radial\_mesh},
#>     type={array of doubles},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={vessel radii},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Radii for flux tally},
#>     notes={}
#>   }
  radial_mesh:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
#>
#>   {\bf num\_theta} num\_theta
#>   \VERAInputTable{
#>     name={num\_theta},
#>     type={integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Number of theta divisions for flux tallies in $[0,2\pi]$},
#>     notes={}
#>   }
  num_theta:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf num\_axial} num\_axial
#>   \VERAInputTable{
#>     name={num\_axial},
#>     type={integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Number of axial levels for flux tallies},
#>     notes={}
#>   }
  num_axial:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf n\_bounds} n\_bounds
#>   \VERAInputTable{
#>     name={n\_bounds},
#>     type={array of decreasing doubles},
#>     need={Optional},
#>     unitsdefault={eV},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Neutron energy bounds for tallies},
#>     notes={}
#>   }
  n_bounds:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - is_strictlydecreasing(stride(1,1,()))
#>
#>   {\bf p\_bounds} p\_bounds
#>   \VERAInputTable{
#>     name={p\_bounds},
#>     type={array of decreasing doubles},
#>     need={Optional},
#>     unitsdefault={eV},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Photon energy bounds for tallies},
#>     notes={}
#>   }
  p_bounds:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - is_strictlydecreasing(stride(1,1,()))
#>
#>   {\bf homog\_type} homog\_type
#>   \VERAInputTable{
#>     name={homog\_type},
#>     type={string},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={assem, rings},
#>     limitations={},
#>     description={If using homogenization, homogenize each assembly or in rings},
#>     notes={Experimental capability}
#>   }
  homog_type:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() assem rings
#>
#>   {\bf homog\_ring\_radii} homog\_ring\_radii
#>   \VERAInputTable{
#>     name={homog\_ring\_radii},
#>     type={},
#>     need={Optional},
#>     unitsdefault={cm},
#>     unitsother={},
#>     valuedefault={Depends on create_unique_pins},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Radii of rings for homogenization},
#>     notes={Applicable if homog_type is rings; Experimental capability}
#>   }
  homog_ring_radii:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - is_strictlyincreasing(stride(1,1,()))
#>
#>   {\bf homog\_pin\_rings} homog\_pin\_rings
#>   \VERAInputTable{
#>     name={homog\_pin\_rings},
#>     type={bool},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={false},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Homogenize according to pin locations or assembly locations},
#>     notes={Applicable when homog_type is rings; Experimental capability}
#>   }
  homog_pin_rings:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf homog\_explicit\_ring} homog\_explicit\_ring
#>   \VERAInputTable{
#>     name={homog\_explicit\_ring},
#>     type={integer},
#>     need={Optional},
#>     unitsdefault={cm},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={$>=0$},
#>     limitations={},
#>     description={Radius to homogenize within and have explicit pins outside of},
#>     notes={Experimental capability}
#>   }
  homog_explicit_ring:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_geq() 0
#>
#>   {\bf bc\_bnd\_mesh} bc\_bnd\_mesh
#>   \VERAInputTable{
#>     name={bc\_bnd\_mesh},
#>     type={array of 6 strings},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={vacuum, vacuum, vacuum, vacuum, vacuum, vacuum},
#>     valuesapplicable={vacuum, reflect},
#>     limitations={},
#>     description={Boundary mesh boundary conditions on
#>                  -x, +x, -y, +y, -z, +z},
#>     notes={}
#>   }
  bc_bnd_mesh:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - arraysize()==6
      - is_word(nth(0,()))
      - in_dictionary(nth(0,()),'reflect','vacuum')
      - is_word(nth(1,()))
      - in_dictionary(nth(1,()),'reflect','vacuum')
      - is_word(nth(2,()))
      - in_dictionary(nth(2,()),'reflect','vacuum')
      - is_word(nth(3,()))
      - in_dictionary(nth(3,()),'reflect','vacuum')
      - is_word(nth(4,()))
      - in_dictionary(nth(4,()),'reflect','vacuum')
      - is_word(nth(5,()))
      - in_dictionary(nth(5,()),'reflect','vacuum')
#>
#>   {\bf x\_bnd\_mesh} x\_bnd\_mesh
#>   \VERAInputTable{
#>     name={x\_bnd\_mesh},
#>     type={array of 2 doubles},
#>     need={Optional},
#>     unitsdefault={cm},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Boundary mesh x-axis limits},
#>     notes={}
#>   }
  x_bnd_mesh:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==2
      - is_float(nth(0,()))
      - is_float(nth(1,()))
#>
#>   {\bf y\_bnd\_mesh} y\_bnd\_mesh
#>   \VERAInputTable{
#>     name={y\_bnd\_mesh},
#>     type={array of 2 doubles},
#>     need={Optional},
#>     unitsdefault={cm},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Boundary mesh y-axis limits},
#>     notes={}
#>   }
  y_bnd_mesh:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==2
      - is_float(nth(0,()))
      - is_float(nth(1,()))
#>
#>   {\bf z\_bnd\_mesh} z\_bnd\_mesh
#>   \VERAInputTable{
#>     name={z\_bnd\_mesh},
#>     type={array of 2 doubles},
#>     need={Optional},
#>     unitsdefault={cm},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Boundary mesh z-axis limits},
#>     notes={}
#>   }
  z_bnd_mesh:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==2
      - is_float(nth(0,()))
      - is_float(nth(1,()))
#>
#>   {\bf core\_translate} core\_translate
#>   \VERAInputTable{
#>     name={core\_translate},
#>     type={array of 3 doubles},
#>     need={Optional},
#>     unitsdefault={cm},
#>     unitsother={},
#>     valuedefault={0.0, 0.0, 0.0},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Position to translate center of core},
#>     notes={}
#>   }
  core_translate:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==3
      - is_float(nth(0,()))
      - is_float(nth(1,()))
      - is_float(nth(2,()))
#>
#>   {\bf create\_unique\_pins} create\_unique\_pins
#>   \VERAInputTable{
#>     name={create\_unique\_pins},
#>     type={bool},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={true},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Make all pincells unique compositions},
#>     notes={}
#>   }
  create_unique_pins:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf track\_isotopes} track\_isotopes
#>   \VERAInputTable{
#>     name={track\_isotopes},
#>     type={string},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={short},
#>     valuesapplicable={short, full},
#>     limitations={},
#>     description={Which set of isotopes to transfer},
#>     notes={}
#>   }
  track_isotopes:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() short full
#>
#>   {\bf xs\_library} xs\_library
#>   \VERAInputTable{
#>     name={xs\_library},
#>     type={string},
#>     need={Required if problem mode is CADIS},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Name of SCALE MG data library file},
#>     notes={Applicable to hybrid simulations}
#>   }
  xs_library:
    <<: *dtword
    _content:
    _check:
      - is_word()
#>
#>   {\bf dimension} dimension
#>   \VERAInputTable{
#>     name={dimension},
#>     type={integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={3},
#>     valuesapplicable={2, 3},
#>     limitations={},
#>     description={Spatial dimension of the problem},
#>     notes={}
#>   }
  dimension:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_geq() 2
      - is_leq() 3
#>
#>   {\bf mesh} mesh
#>   \VERAInputTable{
#>     name={mesh},
#>     type={integer},
#>     need={},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Number of mesh cells per pincell},
#>     notes={Applicable to hybrid simulations}
#>   }
  mesh:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf refl\_mesh\_size} refl\_mesh\_size
#>   \VERAInputTable{
#>     name={refl\_mesh\_size},
#>     type={double},
#>     need={},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={$>0.0$},
#>     limitations={},
#>     description={Radial reflector region mesh size},
#>     notes={Applicable to hybrid simulations}
#>   }
  refl_mesh_size:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
#>
#>   {\bf extend\_axial\_mesh\_size} extend\_axial\_mesh\_size
#>   \VERAInputTable{
#>     name={extend\_axial\_mesh\_size},
#>     type={double},
#>     need={},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={$>0.0$},
#>     limitations={},
#>     description={Axial excore region mesh size},
#>     notes={Applicable to hybrid simulations}
#>   }
  extend_axial_mesh_size:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
#>
#>   {\bf output\_adjoint} output\_adjoint
#>   \VERAInputTable{
#>     name={output\_adjoint},
#>     type={bool},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={false},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Output adjoint flux to Shift HDF5 file and adjoint source to a separate HDF5 file},
#>     notes={Applicable to hybrid simulations}
#>   }
  output_adjoint:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf adjoint} adjoint
#>   \VERAInputTable{
#>     name={adjoint},
#>     type={bool},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={true},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Perform adjoint solve},
#>     notes={Applicable to hybrid simulations}
#>   }
  adjoint:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf num\_blocks\_i} num\_blocks\_i
#>   \VERAInputTable{
#>     name={num\_blocks\_i},
#>     type={integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={depends on number of processors},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Number of partitions (processors) in x},
#>     notes={Applicable to hybrid simulations}
#>   }
  num_blocks_i:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf num\_blocks\_j} num\_blocks\_j
#>   \VERAInputTable{
#>     name={num\_blocks\_j},
#>     type={integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={depends on number of processors},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Number of partitions (processors) in y},
#>     notes={Applicable to hybrid simulations}
#>   }
  num_blocks_j:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf num\_z\_blocks} num\_z\_blocks
#>   \VERAInputTable{
#>     name={num\_z\_blocks},
#>     type={integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={depends on mesh},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Number of pipelining blocks in z},
#>     notes={Applicable to hybrid simulations}
#>   }
  num_z_blocks:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf num\_sets} num\_sets
#>   \VERAInputTable{
#>     name={num\_sets},
#>     type={integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Number of energy sets},
#>     notes={Applicable to hybrid simulations}
#>   }
  num_sets:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf num\_groups} num\_groups
#>   \VERAInputTable{
#>     name={num\_groups},
#>     type={integer},
#>     need={Required for hybrid},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Number of energy groups},
#>     notes={Applicable to hybrid simulations}
#>   }
  num_groups:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf max\_delta\_z} max\_delta\_z
#>   \VERAInputTable{
#>     name={max\_delta\_z},
#>     type={double},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={$>0.0$},
#>     limitations={},
#>     description={Maximum mesh size in z},
#>     notes={Applicable to hybrid simulations}
#>   }
  max_delta_z:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
#>
#>   {\bf partition\_upscatter} partition\_upscatter
#>   \VERAInputTable{
#>     name={partition\_upscatter},
#>     type={bool},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={false},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Partition energy over upscatter groups only},
#>     notes={Applicable to hybrid simulations}
#>   }
  partition_upscatter:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf store\_fulcrum\_string} store\_fulcrum\_string
#>   \VERAInputTable{
#>     name={store\_fulcrum\_string},
#>     type={string},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={true if using 35 nodes or fewer},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Save fulcrum string as file},
#>     notes={Applicable to hybrid simulations}
#>   }
  store_fulcrum_string:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf upscatter\_solver} upscatter\_solver
#>   \VERAInputTable{
#>     name={upscatter\_solver},
#>     type={string},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={gauss_seidel},
#>     valuesapplicable={gauss_seidel, gmres},
#>     limitations={},
#>     description={Which upscatter solver to use},
#>     notes={Applicable to hybrid simulations}
#>   }
  upscatter_solver:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() gauss_seidel gmres
#>
#>   {\bf within\_group\_solver} within\_group\_solver
#>   \VERAInputTable{
#>     name={within\_group\_solver},
#>     type={string},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={gmres},
#>     valuesapplicable={gmres},
#>     limitations={},
#>     description={Which within group solver to use},
#>     notes={Applicable to hybrid simulations}
#>   }
  within_group_solver:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() gmres
#>
#>   {\bf iterate\_downscatter} iterate\_downscatter
#>   \VERAInputTable{
#>     name={iterate\_downscatter},
#>     type={bool},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={false},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Iterate over downscatter groups},
#>     notes={Applicable to hybrid simulations}
#>   }
  iterate_downscatter:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf downscatter} downscatter
#>   \VERAInputTable{
#>     name={downscatter},
#>     type={bool},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={false},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Downscatter only},
#>     notes={Applicable to hybrid simulations}
#>   }
  downscatter:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf Pn\_order} Pn\_order
#>   \VERAInputTable{
#>     name={Pn\_order},
#>     type={integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={0},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Order of moments},
#>     notes={Applicable to hybrid simulations}
#>   }
  Pn_order:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_geq() 0
#>
#>   {\bf upscatter\_subspace\_size} upscatter\_subspace\_size
#>   \VERAInputTable{
#>     name={upscatter\_subspace\_size},
#>     type={integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={100 if eq_set is spn_fv, 30 otherwise},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Maximum subspace size for upscatter solver},
#>     notes={Applicable when upscatter\_solver is gmres}
#>   }
  upscatter_subspace_size:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf within\_group\_subspace\_size} within\_group\_subspace\_size
#>   \VERAInputTable{
#>     name={within\_group\_subspace\_size},
#>     type={integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={20},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Maximum subspace size for within group solver},
#>     notes={Applicable when within\_group\_solver is gmres}
#>   }
  within_group_subspace_size:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf upscatter\_max\_itr} upscatter\_max\_itr
#>   \VERAInputTable{
#>     name={upscatter\_max\_itr},
#>     type={integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1000},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Maximum number of iterations for upscatter solve},
#>     notes={Applicable to hybrid simulations}
#>   }
  upscatter_max_itr:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf within\_group\_max\_itr} within\_group\_max\_itr
#>   \VERAInputTable{
#>     name={within\_group\_max\_itr},
#>     type={integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1000},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Maximum number of iterations for within group solve},
#>     notes={Applicable to hybrid simulations}
#>   }
  within_group_max_itr:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf eq\_set} eq\_set
#>   \VERAInputTable{
#>     name={eq\_set},
#>     type={string},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={sc},
#>     valuesapplicable={bld, bld_2d, ld, sc, spn_fv},
#>     limitations={},
#>     description={Solution method or spatial discretization},
#>     notes={Applicable to hybrid simulations}
#>   }
  eq_set:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() sc ld bld bld_2d spn_fv
#>
#>   {\bf upscatter\_verbosity} upscatter\_verbosity
#>   \VERAInputTable{
#>     name={upscatter\_verbosity},
#>     type={string},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={low},
#>     valuesapplicable={none, low, medium, high},
#>     limitations={},
#>     description={Solver verbosity},
#>     notes={Applicable to hybrid simulations}
#>   }
  upscatter_verbosity:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() none low medium high
#>
#>   {\bf within\_group\_verbosity} within\_group\_verbosity
#>   \VERAInputTable{
#>     name={within\_group\_verbosity},
#>     type={string},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={low},
#>     valuesapplicable={none, low, medium, high},
#>     limitations={},
#>     description={Solver verbosity},
#>     notes={Applicable to hybrid simulations}
#>   }
  within_group_verbosity:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() none low medium high
#>
#>   {\bf new\_grp\_bounds}  new\_grp\_bounds
#>   \VERAInputTable{
#>     name={new\_grp\_bounds},
#>     type={array of decreasing doubles},
#>     need={Optional},
#>     unitsdefault={eV},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={$>0.0$},
#>     limitations={},
#>     description={Collapsed group boundaries},
#>     notes={Applicable to hybrid simulations}
#>   }
  new_grp_bounds:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_float(shift)},())
      - fall(sub{is_gt(shift,0)},())
#>
#>   {\bf grp\_collapse\_src}  grp\_collapse\_src
#>   \VERAInputTable{
#>     name={grp\_collapse\_src},
#>     type={array of doubles},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={depends on xs_library},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Source to do group collapse},
#>     notes={Applicable to hybrid simulations}
#>   }
  grp_collapse_src:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_float(shift)},())
      - fall(sub{is_geq(shift,0)},())
#>
#>   {\bf quad\_type} quad\_type
#>   \VERAInputTable{
#>     name={quad\_type},
#>     type={string},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={qr},
#>     valuesapplicable={qr, levelsym, galerkin, glproduct, ldfe},
#>     limitations={},
#>     description={Type of $S_N$ quadrature},
#>     notes={Applicable to hybrid simulations}
#>   }
  quad_type:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() qr levelsym galerkin glproduct ldfe
#>
#>   {\bf polars\_octant} polars\_octant
#>   \VERAInputTable{
#>     name={polars\_octant},
#>     type={integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={6 (2 if adjoint)},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Number of polar angles per octant for $S_N$ quadrature},
#>     notes={Applicable to hybrid simulations}
#>   }
  polars_octant:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf azimuthals\_octant} azimuthals\_octant
#>   \VERAInputTable{
#>     name={azimuthals\_octant},
#>     type={integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={8 (4 if adjoint)},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Number of azimuthal angles per octant for $S_N$ quadrature},
#>     notes={Applicable to hybrid simulations}
#>   }
  azimuthals_octant:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf Sn\_order} Sn\_order
#>   \VERAInputTable{
#>     name={Sn\_order},
#>     type={integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={4},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Level-symmetric quadrature set order},
#>     notes={Applicable to hybrid simulations}
#>   }
  Sn_order:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf upscatter\_tolerance} upscatter\_tolerance
#>   \VERAInputTable{
#>     name={upscatter\_tolerance},
#>     type={double},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1E-04},
#>     valuesapplicable={(0,1)},
#>     limitations={},
#>     description={Upscatter solver convergence tolerance},
#>     notes={}
#>   }
  upscatter_tolerance:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
      - is_lt() 1
#>
#>   {\bf within\_group\_tolerance} within\_group\_tolerance
#>   \VERAInputTable{
#>     name={within\_group\_tolerance},
#>     type={double},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1E-04},
#>     valuesapplicable={(0,1)},
#>     limitations={},
#>     description={Within group solver convergence tolerance},
#>     notes={}
#>   }
  within_group_tolerance:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
      - is_lt() 1
#>
#>   {\bf cell\_homogenize} cell\_homogenize
#>   \VERAInputTable{
#>     name={cell\_homogenize},
#>     type={bool},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={false},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Homogenize material in cells},
#>     notes={}
#>   }
  cell_homogenize:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf SPN\_matrix\_type} SPN\_matrix\_type
#>   \VERAInputTable{
#>     name={SPN\_matrix\_type},
#>     type={string},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={mat_free},
#>     limitations={},
#>     description={Type of $SP_N$ matrix solve},
#>     notes={}
#>   }
  SPN_matrix_type:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() mat_free
#>
#>   {\bf SPN\_order} SPN\_order
#>   \VERAInputTable{
#>     name={SPN\_order},
#>     type={integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1},
#>     valuesapplicable={1, 3, 5, 7},
#>     limitations={},
#>     description={Order of $SP_N$ solve},
#>     notes={}
#>   }
  SPN_order:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 1 3 5 7
#>
#>   {\bf Pn\_correction} Pn\_correction
#>   \VERAInputTable{
#>     name={Pn\_correction},
#>     type={bool},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={false},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Use outscatter-corrected diffusion coefficient to reduce memory in solve},
#>     notes={}
#>   }
  Pn_correction:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf pin\_partitioning} pin\_partitioning
#>   \VERAInputTable{
#>     name={pin\_partitioning},
#>     type={bool},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={false},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Partition mesh over pincells},
#>     notes={}
#>   }
  pin_partitioning:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false

COBRATF:

#>
#>   {\bf nfuel} nfuel
#>   \VERAInputTable{
#>     name={nfuel},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={10},
#>     valuesapplicable={>0},
#>     limitations={},
#>     description={The number of rings in the fuel rod pellet (only effective when nc>0).},
#>     notes={}
#>   }
  nfuel:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf min_steps} min_steps
#>   \VERAInputTable{
#>     name={min_steps},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={4},
#>     valuesapplicable={>=0},
#>     limitations={},
#>     description={The minimum number of iterations CTF should take during a solve},
#>     notes={}
#>   }
  min_steps:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_geq() 0
#>
#>   {\bf imox} imox
#>   \VERAInputTable{
#>     name={imox},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={0},
#>     valuesapplicable={0, 1, 2, 3, 4, 5},
#>     limitations={},
#>     description={The fuel thermal conductivity model to use in CTF (only effective when nc>0). Options are:
#>        0 - MATPRO-11
#>        1 - Modified NFI (UO2)
#>        2 - Halden (UO2)
#>        3 - Duriez/Modified NFI (MOX)
#>        4 - Halden (MOX)
#>        5 - Amaya (MOX)},
#>     notes={}
#>   }
  imox:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 0 1 2 3 4 5
#>
#>   {\bf nc} nc
#>   \VERAInputTable{
#>     name={nfuel},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1},
#>     valuesapplicable={0, 1, 2, 3},
#>     limitations={},
#>     description={The fuel rod conduction model.  Options are: (0) No conduction, power is supplied as a
#>       surface heat flux (can lead to numerical stability issues), (1) Conduction in the radial direction
#>       only, (2) Conduction in the radial and azimuthal directions, (3) Conduction in the radial, azimuthal
#>       and axial directions.},
#>     notes={}
#>   }
  nc:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 0 1 2 3
#>
#>   {\bf chf} chf
#>   \VERAInputTable{
#>     name={chf},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1},
#>     valuesapplicable={0, 1, 2},
#>     limitations={},
#>     description={
#>       CHF model option.  Options are:
#>        0 - No CHF check during transient (post-sim check using W-3)
#>        1 - Check CHF during transient using W-3
#>        2 - No CHF check during or after simulation (set CHF to infinity)},
#>     notes={}
#>   }
  chf:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 0 1 2
#>
#>   {\bf debug} debug
#>   \VERAInputTable{
#>     name={debug},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={0},
#>     valuesapplicable={0, 1},
#>     limitations={},
#>     description={Setting to 1 will cause CTF to print every power distribution it receives to a separate
#>       HDF5 file.  This can be used to run CTF standalone on a power distribution that causes it to crash.},
#>     notes={}
#>   }
  debug:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 0 1
#>
#>   {\bf irfc} irfc
#>   \VERAInputTable{
#>     name={irfc},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={2},
#>     valuesapplicable={1, 2, 3, 4},
#>     limitations={},
#>     description={
#>        Friction model:
#>        1 - original CTF model
#>        2 - new CTF model
#>        3 - Colebrook
#>        4 - Sylvester},
#>     notes={}
#>   }
  irfc:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 1 2 3 4
#>
#>   {\bf dhfrac} dhfrac
#>   \VERAInputTable{
#>     name={dhfrac},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={0.026},
#>     valuesapplicable={>=0.0},
#>     limitations={},
#>     description={Percentage of rod heat directly deposited into fluid (gamma heating)},
#>     notes={}
#>   }
  dhfrac:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_geq() 0
#>
#>   {\bf guide_tube_coefficient} guide_tube_coefficient
#>   \VERAInputTable{
#>     name={guide_tube_coefficient},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={0.0},
#>     valuesapplicable={0.0<=guide_tube_coefficient<=1.0},
#>     limitations={},
#>     description={Used to determine the temperature rise in guide tubes using the following:
#>           T_guide_tube(z) = (T_fluid(z)-T_inlet)*guide_tube_coefficient+T_inlet
#>        where T_guide_tube is the temperature in the guide tube, T_fluid is the temperature in the channels
#>        adjacent to the guide tube, and T_inlet is the inlet temperature.  0.0 means the guide tube outlet
#>        temperature will be the same as the inlet temperature and 1.0 means it will be equal to the fluid side
#>        outlet temperature.},
#>     notes={}
#>   }
  guide_tube_coefficient:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_geq() 0.0
      - is_leq() 1.0
#>
#>   {\bf beta_htc} beta_htc
#>   \VERAInputTable{
#>     name={beta_htc},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={0.2},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={The boiling heat transfer coefficient under-relaxation coefficient.  Because of the semi-implicit
#>        coupling of the fluid and energy equations in the CTF numerical solution, it is necessary to under-relax the
#>        heat transfer coefficient in time for numerical stability.  For some boiling cases, it may be necessary to increase the
#>        under-relaxation.},
#>     notes={}
#>   }
  beta_htc:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_geq() 0
#>
#>   {\bf hgap} hgap
#>   \VERAInputTable{
#>     name={hgap},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={W/m**2/K},
#>     unitsother={},
#>     valuedefault={5678.3},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets the gap conductance in the fuel rod gap (only applicable when using a constant gap conductance fuel rod model).},
#>     notes={}
#>   }
  hgap:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
#>
#>   {\bf clad_material} clad_material
#>   \VERAInputTable{
#>     name={clad_material},
#>     type={string},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={zirc},
#>     valuesapplicable={zirc, ss, sic},
#>     limitations={},
#>     description={Sets the clad material properties.  Currently has no effect in CTF.  Cladding material properties always default to Zircaloy.},
#>     notes={}
#>   }
  clad_material:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() zirc ss sic
#>
#>   {\bf epso} epso
#>   \VERAInputTable{
#>     name={epso},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1e-4},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Relative tolerance for the linear solver (pressure matrix solve).  Only applicable when using
#>        an iterative solver.  Setting too high can lead to numerical instability.},
#>     notes={}
#>   }
  epso:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
#>
#>   {\bf iitmax} iitmax
#>   \VERAInputTable{
#>     name={iitmax},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={160},
#>     valuesapplicable={>0},
#>     limitations={},
#>     description={Maximum number of iterations to take in the linear solve (pressure matrix solve).  Only
#>        applicable when using an iterative solver.  Setting too low can lead to numerical instabilities.},
#>     notes={}
#>   }
  iitmax:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf dtmin} dtmin
#>   \VERAInputTable{
#>     name={dtmin},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={s},
#>     unitsother={},
#>     valuedefault={1e-6},
#>     valuesapplicable={>0},
#>     limitations={},
#>     description={Sets the minimum allowable timestep size.  Used for both transients and steady state (because CTF
#>        solves a transient to get to steady state).  If the timestep size needs to be reduced smaller than this value,
#>        the code will crash with a "cannot reduce timestep size" error.},
#>     notes={}
#>   }
  dtmin:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
#>
#>   {\bf dtmax} dtmax
#>   \VERAInputTable{
#>     name={dtmax},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={s},
#>     unitsother={},
#>     valuedefault={0.1},
#>     valuesapplicable={>0},
#>     limitations={},
#>     description={Sets the maximum allowable timestep size.  Used for both transients and steady state (because CTF
#>        solves a transient to get to steady state).  CTF uses dynamic timestep selection which is mainly a function
#>        of the Courant number.  This puts a ceiling on the dynamic timestep size to prevent numerical instability.},
#>     notes={}
#>   }
  dtmax:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
#>
#>   {\bf rtwfp} rtwfp
#>   \VERAInputTable{
#>     name={rtwfp},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={100.0},
#>     valuesapplicable={>=1.0},
#>     limitations={},
#>     description={Sets the ratio between the conduction and fluid timestep sizes.  For steady state problems,
#>        the timestep sizes of the conduction equation can be set larger than the fluid timestep sizes to reduce
#>        computational time.  For transients, CTF will override this to be 1.0.  Setting this too high can lead
#>        to numerical instability.},
#>     notes={}
#>   }
  rtwfp:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_geq() 1
#>
#>   {\bf maxits} maxits
#>   \VERAInputTable{
#>     name={maxits},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={10000},
#>     valuesapplicable={>=1},
#>     limitations={},
#>     description={Sets the maximum number of iterations CTF will take during any individual steady state solve.
#>        If the iterations go over this maximum value, CTF will crash on an unable to converge exception.},
#>     notes={}
#>   }
  maxits:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_geq() 1
#>
#>   {\bf courant} courant
#>   \VERAInputTable{
#>     name={courant},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={0.8},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets the Courant number to use when setting timesteps size.  Setting this value lower will
#>        lead to overall smaller timestep sizes being used in CTF and setting it larger will lead to overall
#>        larger timestep sizes being used.  It is not recommended that the user adjust this value as it typically
#>        is not an effective means of improving CTF convergence.},
#>     notes={}
#>   }
  courant:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
#>
#>   {\bf solver} solver
#>   \VERAInputTable{
#>     name={solver},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={3/5},
#>     valuesapplicable={0, 3, 5, 6, 7, 8},
#>     limitations={},
#>     description={Selects the linear solver to use for the pressure matrix solve.  Options are:
#>        0 - Direct (Gaussian elimination)     (serial runs only)
#>        3 - Internal Krylov solver (BiCGStab) (serial runs only, default for serial run)
#>        5 - PETSc BiCGStab (default for parallel run)
#>        6 - PETSc with pressure matrix reduced to root and solved in serial (used only for parallel verification cases, do not use for production parallel runs)
#>        7 - PETSc BiCGStab using block Jacobi preconditioner
#>        8 - Trillinos BiCGStab solver},
#>     notes={}
#>   }
  solver:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 0 3 5 6 7 8
#>
#>   {\bf parallel} parallel
#>   \VERAInputTable{
#>     name={parallel},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1},
#>     valuesapplicable={0, 1},
#>     limitations={},
#>     description={Instructs CTF to run in serial (0) or in parallel (1)},
#>     notes={}
#>   }
  parallel:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 0 1
#>
#>   {\bf global_energy_balance} global_energy_balance
#>   \VERAInputTable{
#>     name={global_energy_balance},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={percent},
#>     unitsother={},
#>     valuedefault={0.01},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets tolerance for energy balance (energy in minus energy out normalized to energy in) for steady state runs.},
#>     notes={}
#>   }
  global_energy_balance:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf global_mass_balance} global_mass_balance
#>   \VERAInputTable{
#>     name={global_mass_balance},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={percent},
#>     unitsother={},
#>     valuedefault={0.01},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets tolerance for mass balance (mass in minus mass out normalized to mass in) for steady state runs.},
#>     notes={}
#>   }
  global_mass_balance:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf fluid_energy_storage} fluid_energy_storage
#>   \VERAInputTable{
#>     name={fluid_energy_storage},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={percent},
#>     unitsother={},
#>     valuedefault={0.5},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets tolerance for energy storage in the fluid (change in energy over a timestep) for steady state runs.
#>        Only applicable when using the storage-based convergence criteria (specify fluid_energy_storage/solid_energy_storage/mass_storage).
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  fluid_energy_storage:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf solid_energy_storage} solid_energy_storage
#>   \VERAInputTable{
#>     name={solid_energy_storage},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={percent},
#>     unitsother={},
#>     valuedefault={0.5},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets tolerance for energy storage in the solid (change in energy over a timestep) for steady state runs.
#>        Only applicable when using the storage-based convergence criteria (specify fluid_energy_storage/solid_energy_storage/mass_storage).
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  solid_energy_storage:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf mass_storage} mass_storage
#>   \VERAInputTable{
#>     name={mass_storage},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={percent},
#>     unitsother={},
#>     valuedefault={0.5},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets tolerance for mass storage in the fluid (change in mass in system over a timestep) for steady state runs.
#>        Only applicable when using the storage-based convergence criteria (specify fluid_energy_storage/solid_energy_storage/mass_storage).
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  mass_storage:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf pressure_criteria} pressure_criteria
#>   \VERAInputTable{
#>     name={pressure_criteria},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1e-4},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets tolerance on l-infinity of pressure change for steady state runs.
#>        Only applicable when using the change-based convergence criteria (specify pressure_criteria, pressurea_criteria,
#>        Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>        vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>        Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>        vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2).
#>        Note that when using the change-based criteria, all criteria are optional.
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  pressure_criteria:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf Tcool_criteria} Tcool_criteria
#>   \VERAInputTable{
#>     name={Tcool_criteria},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1e-3},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets tolerance on l-infinity of coolant temperature for steady state runs.
#>        Only applicable when using the change-based convergence criteria (specify pressure_criteria, pressurea_criteria,
#>        Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>        vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>        Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>        vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2).
#>        Note that when using the change-based criteria, all criteria are optional.
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  Tcool_criteria:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf Tsolid_criteria} Tsolid_criteria
#>   \VERAInputTable{
#>     name={Tsolid_criteria},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1e-3},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets tolerance on l-infinity of solid temperature for steady state runs.
#>        Only applicable when using the change-based convergence criteria (specify pressure_criteria, pressurea_criteria,
#>        Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>        vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>        Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>        vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2).
#>        Note that when using the change-based criteria, all criteria are optional.
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  Tsolid_criteria:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf void_criteria} void_criteria
#>   \VERAInputTable{
#>     name={void_criteria},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1e-4},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets tolerance on l-infinity of void for steady state runs.
#>        Only applicable when using the change-based convergence criteria (specify pressure_criteria, pressurea_criteria,
#>        Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>        vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>        Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>        vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2).
#>        Note that when using the change-based criteria, all criteria are optional.  Not checked for single phase runs.
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  void_criteria:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf vliq_criteria} vliq_criteria
#>   \VERAInputTable{
#>     name={vliq_criteria},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1e-3},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets tolerance on l-infinity of liquid velocity for steady state runs.
#>        Only applicable when using the change-based convergence criteria (specify pressure_criteria, pressurea_criteria,
#>        Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>        vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>        Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>        vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2).
#>        Note that when using the change-based criteria, all criteria are optional.
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  vliq_criteria:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf vvap_criteria} vvap_criteria
#>   \VERAInputTable{
#>     name={vvap_criteria},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1e-2},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets tolerance on l-infinity of vapor velocity for steady state runs.
#>        Only applicable when using the change-based convergence criteria (specify pressure_criteria, pressurea_criteria,
#>        Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>        vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>        Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>        vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2).
#>        Note that when using the change-based criteria, all criteria are optional.  Not checked for single phase runs.
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  vvap_criteria:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf vdrop_criteria} vdrop_criteria
#>   \VERAInputTable{
#>     name={vdrop_criteria},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1e-2},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets tolerance on l-infinity of droplet velocity for steady state runs.
#>        Only applicable when using the change-based convergence criteria (specify pressure_criteria, pressurea_criteria,
#>        Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>        vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>        Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>        vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2).
#>        Note that when using the change-based criteria, all criteria are optional.  Not checked for single phase runs.
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  vdrop_criteria:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf pressurea_criteria} pressurea_criteria
#>   \VERAInputTable{
#>     name={pressurea_criteria},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={bar},
#>     unitsother={},
#>     valuedefault={1e-3},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets absolute tolerance on l-infinity of pressure for steady state runs.
#>        Only applicable when using the change-based convergence criteria (specify pressure_criteria, pressurea_criteria,
#>        Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>        vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>        Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>        vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2).
#>        Note that when using the change-based criteria, all criteria are optional.
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  pressurea_criteria:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf Tcoola_criteria} Tcoola_criteria
#>   \VERAInputTable{
#>     name={Tcoola_criteria},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={K},
#>     unitsother={},
#>     valuedefault={1e-3},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets absolute tolerance on l-infinity of coolant temperature for steady state runs.
#>        Only applicable when using the change-based convergence criteria (specify pressure_criteria, pressurea_criteria,
#>        Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>        vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>        Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>        vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2).
#>        Note that when using the change-based criteria, all criteria are optional.
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  Tcoola_criteria:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf Tsolida_criteria} Tsolida_criteria
#>   \VERAInputTable{
#>     name={Tsolida_criteria},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={K},
#>     unitsother={},
#>     valuedefault={1e-3},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets absolute tolerance on l-infinity of solid temperature for steady state runs.
#>        Only applicable when using the change-based convergence criteria (specify pressure_criteria, pressurea_criteria,
#>        Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>        vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>        Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>        vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2).
#>        Note that when using the change-based criteria, all criteria are optional.
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  Tsolida_criteria:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf vliqa_criteria} vliqa_criteria
#>   \VERAInputTable{
#>     name={vliqa_criteria},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={m/s},
#>     unitsother={},
#>     valuedefault={1e-3},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets absolute tolerance on l-infinity of liquid velocity for steady state runs.
#>        Only applicable when using the change-based convergence criteria (specify pressure_criteria, pressurea_criteria,
#>        Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>        vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>        Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>        vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2).
#>        Note that when using the change-based criteria, all criteria are optional.
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  vliqa_criteria:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf vvapa_criteria} vvapa_criteria
#>   \VERAInputTable{
#>     name={vvapa_criteria},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={m/s},
#>     unitsother={},
#>     valuedefault={1e-2},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets absolute tolerance on l-infinity of vapor velocity for steady state runs.
#>        Only applicable when using the change-based convergence criteria (specify pressure_criteria, pressurea_criteria,
#>        Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>        vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>        Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>        vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2).
#>        Note that when using the change-based criteria, all criteria are optional. Not used for single-phase runs.
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  vvapa_criteria:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf vdropa_criteria} vdropa_criteria
#>   \VERAInputTable{
#>     name={vdropa_criteria},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={m/s},
#>     unitsother={},
#>     valuedefault={1e-2},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets absolute tolerance on l-infinity of droplet velocity for steady state runs.
#>        Only applicable when using the change-based convergence criteria (specify pressure_criteria, pressurea_criteria,
#>        Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>        vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>        Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>        vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2).
#>        Note that when using the change-based criteria, all criteria are optional. Not used for single-phase runs.
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  vdropa_criteria:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf pressure_criteria_l2} pressure_criteria_l2
#>   \VERAInputTable{
#>     name={pressure_criteria_l2},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1e-5},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets relative tolerance on l-2 of pressure for steady state runs.
#>        Only applicable when using the change-based convergence criteria (specify pressure_criteria, pressurea_criteria,
#>        Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>        vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>        Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>        vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2).
#>        Note that when using the change-based criteria, all criteria are optional.
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  pressure_criteria_l2:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf Tcool_criteria_l2} Tcool_criteria_l2
#>   \VERAInputTable{
#>     name={Tcool_criteria_l2},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1e-4},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets relative tolerance on l-2 of coolant temperature for steady state runs.
#>        Only applicable when using the change-based convergence criteria (specify pressure_criteria, pressurea_criteria,
#>        Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>        vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>        Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>        vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2).
#>        Note that when using the change-based criteria, all criteria are optional.
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  Tcool_criteria_l2:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf Tsolid_criteria_l2} Tsolid_criteria_l2
#>   \VERAInputTable{
#>     name={Tsolid_criteria_l2},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1e-4},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets relative tolerance on l-2 of solid temperature for steady state runs.
#>        Only applicable when using the change-based convergence criteria (specify pressure_criteria, pressurea_criteria,
#>        Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>        vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>        Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>        vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2).
#>        Note that when using the change-based criteria, all criteria are optional.
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  Tsolid_criteria_l2:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf void_criteria_l2} void_criteria_l2
#>   \VERAInputTable{
#>     name={void_criteria_l2},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1e-5},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets absolute tolerance on l-2 of void for steady state runs.
#>        Only applicable when using the change-based convergence criteria (specify pressure_criteria, pressurea_criteria,
#>        Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>        vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>        Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>        vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2).
#>        Note that when using the change-based criteria, all criteria are optional. Not used in single phase runs.
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  void_criteria_l2:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf vliq_criteria_l2} vliq_criteria_l2
#>   \VERAInputTable{
#>     name={vliq_criteria_l2},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1e-4},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets relative tolerance on l-2 of liquid velocity for steady state runs.
#>        Only applicable when using the change-based convergence criteria (specify pressure_criteria, pressurea_criteria,
#>        Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>        vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>        Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>        vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2).
#>        Note that when using the change-based criteria, all criteria are optional.
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  vliq_criteria_l2:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf vvap_criteria_l2} vvap_criteria_l2
#>   \VERAInputTable{
#>     name={vvap_criteria_l2},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1e-4},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets relative tolerance on l-2 of vapor velocity for steady state runs.
#>        Only applicable when using the change-based convergence criteria (specify pressure_criteria, pressurea_criteria,
#>        Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>        vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>        Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>        vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2).
#>        Note that when using the change-based criteria, all criteria are optional.  Not used for single-phase runs.
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  vvap_criteria_l2:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf vdrop_criteria_l2} vdrop_criteria_l2
#>   \VERAInputTable{
#>     name={vdrop_criteria_l2},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1e-4},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets relative tolerance on l-2 of droplet velocity for steady state runs.
#>        Only applicable when using the change-based convergence criteria (specify pressure_criteria, pressurea_criteria,
#>        Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>        vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>        Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>        vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2).
#>        Note that when using the change-based criteria, all criteria are optional.  Not used for single-phase runs.
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  vdrop_criteria_l2:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf pressure_criteria_l2} pressure_criteria_l2
#>   \VERAInputTable{
#>     name={pressure_criteria_l2},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1e-5},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets relative tolerance on l-2 of pressure for steady state runs.
#>        Only applicable when using the change-based convergence criteria (specify pressure_criteria, pressurea_criteria,
#>        Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>        vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>        Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>        vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2).
#>        Note that when using the change-based criteria, all criteria are optional.
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  pressurea_criteria_l2:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf Tcoola_criteria_l2} Tcoola_criteria_l2
#>   \VERAInputTable{
#>     name={Tcoola_criteria_l2},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={K},
#>     unitsother={},
#>     valuedefault={1e-5},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets absolute tolerance on l-2 of coolant temperature for steady state runs.
#>        Only applicable when using the change-based convergence criteria (specify pressure_criteria, pressurea_criteria,
#>        Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>        vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>        Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>        vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2).
#>        Note that when using the change-based criteria, all criteria are optional.
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  Tcoola_criteria_l2:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf Tsolida_criteria_l2} Tsolida_criteria_l2
#>   \VERAInputTable{
#>     name={Tsolida_criteria_l2},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={K},
#>     unitsother={},
#>     valuedefault={1e-5},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets absolute tolerance on l-2 of solid temperature for steady state runs.
#>        Only applicable when using the change-based convergence criteria (specify pressure_criteria, pressurea_criteria,
#>        Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>        vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>        Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>        vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2).
#>        Note that when using the change-based criteria, all criteria are optional.
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  Tsolida_criteria_l2:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf vliqa_criteria_l2} vliqa_criteria_l2
#>   \VERAInputTable{
#>     name={vliqa_criteria_l2},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={m/s},
#>     unitsother={},
#>     valuedefault={1e-5},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets absolute tolerance on l-2 of liquid velocity for steady state runs.
#>        Only applicable when using the change-based convergence criteria (specify pressure_criteria, pressurea_criteria,
#>        Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>        vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>        Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>        vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2).
#>        Note that when using the change-based criteria, all criteria are optional.
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  vliqa_criteria_l2:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf vvpaa_criteria_l2} vvapa_criteria_l2
#>   \VERAInputTable{
#>     name={vvapa_criteria_l2},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={m/s},
#>     unitsother={},
#>     valuedefault={1e-4},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets absolute tolerance on l-2 of vapor velocity for steady state runs.
#>        Only applicable when using the change-based convergence criteria (specify pressure_criteria, pressurea_criteria,
#>        Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>        vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>        Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>        vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2).
#>        Note that when using the change-based criteria, all criteria are optional.  Not used for single-phase runs.
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  vvapa_criteria_l2:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf vdropa_criteria_l2} vdropa_criteria_l2
#>   \VERAInputTable{
#>     name={vdropa_criteria_l2},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={m/s},
#>     unitsother={},
#>     valuedefault={1e-4},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets absolute tolerance on l-2 of droplet velocity for steady state runs.
#>        Only applicable when using the change-based convergence criteria (specify pressure_criteria, pressurea_criteria,
#>        Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>        vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>        Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>        vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2).
#>        Note that when using the change-based criteria, all criteria are optional.  Not used for single-phase runs.
#>        See CTF User Manual for more details.},
#>     notes={}
#>   }
  vdropa_criteria_l2:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf use_sol_stop_crit} use_sol_stop_crit
#>   \VERAInputTable{
#>     name={use_sol_stop_crit},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={0},
#>     valuesapplicable={0 1},
#>     limitations={},
#>     description={Selects the stopping criteria to use for steady state runs.  Options are:
#>        0 - storage-based criteria (global_energy_balance, global_mass_balance, fluid_energy_storage, solid_energy_storage, mass_storage)
#>        1 - change-based criteria (global_energy_balance, global_mass_balance, pressure_criteria, pressurea_criteria,
#>            Tcool_criteria, Tcoola_criteria, Tsolid_criteria, Tsolida_criteria, void_criteria, vliq_criteria, vliqa_criteria,
#>            vvap_criteria, vvapa_criteria, vdrop_criteria, vdropa_criteria, void_criteria_l2, Tcool_criteria_l2,
#>            Tcoola_criteria_l2, Tsolid_criteria_l2, Tsolida_criteria_l2, pressure_criteria_l2, pressurea_criteria_l2,
#>            vliq_criteria_l2, vliqa_criteria_l2, vvap_criteria_l2, vvapa_criteria_l2, vdrop_criteria_l2, vdropa_criteria_l2)
#>        All criteria are optional with defaults.}
#>     notes={}
#>   }
  use_sol_stop_crit:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 0 1
#>
#>   {\bf proc_per_assem} proc_per_assem
#>   \VERAInputTable{
#>     name={proc_per_assem},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={0},
#>     valuesapplicable={1 4 9 16},
#>     limitations={},
#>     description={Sets the number of domains to divide each full assembly into for parallel runs.
#>        Only applicable for parallel runs.  The higher the number, the more cores CTF will use and the faster
#>        it will run in a parallel model.  However, the number of cores required by CTF must be less than or
#>        equal to the number required by VERA-CS and the number of cores available on the system.},
#>     notes={}
#>   }
  proc_per_assem:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 1 4 9 16
#>
#>   {\bf edit_gaps} edit_gaps
#>   \VERAInputTable{
#>     name={edit_gaps},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={0},
#>     valuesapplicable={0 1},
#>     limitations={},
#>     description={Set to 1 to write an output file from CTF specifying gap (lateral flow path) solution data.
#>        This file will be large for full-core models.},
#>     notes={}
#>   }
  edit_gaps:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 0 1
#>
#>   {\bf edit_main_text_output} edit_main_text_output
#>   \VERAInputTable{
#>     name={edit_main_text_output},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={0},
#>     valuesapplicable={0 1},
#>     limitations={},
#>     description={Set to 1 to write the main text output file from CTF summarizing solution data.
#>        This file will be large for full-core models.},
#>     notes={}
#>   }
  edit_main_text_output:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 0 1
#>
#>   {\bf edit_channels} edit_channels
#>   \VERAInputTable{
#>     name={edit_channels},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={0},
#>     valuesapplicable={0 1},
#>     limitations={},
#>     description={Set to 1 to write the channel text output file from CTF summarizing solution data.
#>        This file will be large for full-core models.},
#>     notes={}
#>   }
  edit_channels:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 0 1
#>
#>   {\bf edit_rods} edit_rods
#>   \VERAInputTable{
#>     name={edit_rods},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={0},
#>     valuesapplicable={0 1},
#>     limitations={},
#>     description={Set to 1 to write rod data to the main text output file from CTF.
#>        This file will be large for full-core models.},
#>     notes={}
#>   }
  edit_rods:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 0 1
#>
#>   {\bf edit_dnb} edit_dnb
#>   \VERAInputTable{
#>     name={edit_dnb},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={0},
#>     valuesapplicable={0 1},
#>     limitations={},
#>     description={Set to 1 to write DNB data to the VERA-CS HDF5 file.},
#>     notes={}
#>   }
  edit_dnb:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 0 1
#>
#>   {\bf edit_dnb_text_file} edit_dnb_text_file
#>   \VERAInputTable{
#>     name={edit_dnb_text_file},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={0},
#>     valuesapplicable={0 1},
#>     limitations={},
#>     description={Set to 1 to write the DNB text file.  This file will be large for full core models.},
#>     notes={}
#>   }
  edit_dnb_text_file:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 0 1
#>
#>   {\bf edit_convergence} edit_convergence
#>   \VERAInputTable{
#>     name={edit_convergence},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1},
#>     valuesapplicable={0 1},
#>     limitations={},
#>     description={Set to 1 to write the convergence information output file from CTF.},
#>     notes={}
#>   }
  edit_convergence:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 0 1
#>
#>   {\bf edit_hdf5} edit_hdf5
#>   \VERAInputTable{
#>     name={edit_hdf5},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1},
#>     valuesapplicable={0 1},
#>     limitations={},
#>     description={Set to 1 to write CTF data to the VERA-CS HDF5 file.}
#>     notes={}
#>   }
  edit_hdf5:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 0 1
#>
#>   {\bf edit_native_hdf5} edit_native_hdf5
#>   \VERAInputTable{
#>     name={edit_native_hdf5},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={0},
#>     valuesapplicable={0 1},
#>     limitations={},
#>     description={Set to 1 to write the CTF native HDF5 file.  This file writes information for all
#>        pins in the model in a more arbitrary way than the VERA-CS HDF5 file, which is organized by
#>        assembly and core location.  This file contains more detailed information than the VERA-CS HDF5 file.
#>        This file can currently only be printed for serial runs.},
#>     notes={}
#>   }
  edit_native_hdf5:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 0 1
#>
#>   {\bf edit_fluid_vtk} edit_fluid_vtk
#>   \VERAInputTable{
#>     name={edit_fluid_vtk},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={0},
#>     valuesapplicable={0 1},
#>     limitations={},
#>     description={Set to 1 to write the CTF fluid VTK file.  This allows the user to visualize solution
#>        results using a VTK reader, but this file will be large for full core models.},
#>     notes={}
#>   }
  edit_fluid_vtk:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 0 1
#>
#>   {\bf edit_rod_vtk} edit_rod_vtk
#>   \VERAInputTable{
#>     name={edit_rod_vtk},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={0},
#>     valuesapplicable={0 1},
#>     limitations={},
#>     description={Set to 1 to write the CTF rod VTK file.  This allows the user to visualize solution
#>        results using a VTK reader, but this file will be large for full core models.},
#>     notes={}
#>   }
  edit_rod_vtk:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 0 1
#>
#>   {\bf hi2lo_sub_axial} hi2lo_sub_axial
#>   \VERAInputTable{
#>     name={hi2lo_sub_axial},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1},
#>     valuesapplicable={>0},
#>     limitations={},
#>     description={Use to set the number of sub-levels to divide each CTF axial level into when forming
#>        the coupling mesh with MAMBA.  Only applicable when using ROTHCON to reconstruct rod surface temperatures
#>        and TKE.},
#>     notes={}
#>   }
  hi2lo_sub_axial:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_geq() 1
#>
#>   {\bf hi2lo_sub_theta} hi2lo_sub_theta
#>   \VERAInputTable{
#>     name={hi2lo_sub_theta},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1},
#>     valuesapplicable={>0},
#>     limitations={},
#>     description={Use to set the number of sub-sectors to divide each CTF rod sector into when forming
#>        the coupling mesh with MAMBA.  Only applicable when using ROTHCON to reconstruct rod surface temperatures
#>        and TKE.},
#>     notes={}
#>   }
  hi2lo_sub_theta:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_geq() 1
#>
#>   {\bf model_corrosion} model_corrosion
#>   \VERAInputTable{
#>     name={model_corrosion},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={0},
#>     valuesapplicable={0 1},
#>     limitations={},
#>     description={Set to 1 to turn on the clad corrosion model in CTF.  Only applicable for crud simulations.},
#>     notes={}
#>   }
  model_corrosion:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 0 1
#>
#>   {\bf gap_model} gap_model
#>   \VERAInputTable{
#>     name={gap_model},
#>     type={string},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={constant},
#>     valuesapplicable={constant dynamic},
#>     limitations={},
#>     description={Sets the fuel rod pellet/clad gap thermal conductivity model.  Can either be constant (user-specified value) or dynamic (CTF will calculate based on thermal expansion and burnup effects).},
#>     notes={}
#>   }
  gap_model:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() constant dynamic
#>
#>   {\bf boil_ht_cor} boil_ht_cor
#>   \VERAInputTable{
#>     name={boil_ht_cor},
#>     type={string},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={thom},
#>     valuesapplicable={chen thom},
#>     limitations={},
#>     description={Sets the boiling heat transfer model.  Options are chen or thom.},
#>     notes={}
#>   }
  boil_ht_cor:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() chen thom
#>
#>   {\bf property_evaluations} property_evaluations
#>   \VERAInputTable{
#>     name={property_evaluations},
#>     type={string},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={iapws1997_lookup},
#>     valuesapplicable={asme1968 iapws1997_direct iapws1997_lookup flibe},
#>     limitations={},
#>     description={Sets the equation of state source to use for fluid properties.  Options are:
#>        asme1968 - ASME 1968 tabls
#>        iapws1997_direct - IAPWS 1997 standard using direct correlation evaluations (will be computationally slower)
#>        iapws1997_lookup - IAPWS 1997 standard lookup tables built from the direct correlation evaluations during initialization (computationally faster to evaluate)
#>        flibe - Generic properties for FLiBe salt coolant},
#>     notes={}
#>   }
  property_evaluations:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() asme asme1968 iapws iapws1997_direct iapws_v2 iapws1997_lookup flibe
#>
#>   {\bf beta_sp} beta_sp
#>   \VERAInputTable{
#>     name={beta_sp},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={0.005},
#>     valuesapplicable={>=0.0},
#>     limitations={},
#>     description={Sets the strength of turbulent mixing causing lateral cross-flow in CTF.  The default
#>        is currently 0.005, but it has been found that 0.037 is more reasonable for bundles with mixing
#>        vane grids (will be updated in the future).},
#>     notes={}
#>   }
  beta_sp:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_geq() 0.0
#>
#>   {\bf k_void_drift} k_void_drift
#>   \VERAInputTable{
#>     name={k_void_drift},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1.4},
#>     valuesapplicable={>=0.0},
#>     limitations={},
#>     description={Sets the equilibrium distribution weighting factor in the void drift model.  Decreasing
#>        this value leads to less void drift and increasing it leads to more.},
#>     notes={}
#>   }
  k_void_drift:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_geq() 0.0
#>
#>   {\bf crud} crud
#>   \VERAInputTable{
#>     name={crud},
#>     type={string},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={MAMBA},
#>     valuesapplicable={MAMBA cicada none},
#>     limitations={},
#>     description={Sets the crud modeling tool.  Only applicable during a crud simulation.},
#>     notes={}
#>   }
  crud:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() none MAMBA cicada

#>
#>   {\bf max_crud_step_size} max_crud_step_size
#>   \VERAInputTable{
#>     name={max_crud_step_size},
#>     type={Float},
#>     need={Optional},
#>     unitsdefault={day},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={$>0$},
#>     limitations={},
#>     description={Maximum number of days in a crud grow.  Setting this smaller than the depletion step size will result in multiple crud grows being made during the depletion step with source term data being updated during each substep.},
#>     notes={}
#>   }
  max_crud_step_size:
    <<: *dtfloat
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf crud_dT_feedback} crud_dT_feedback
#>   \VERAInputTable{
#>     name={crud_dT_feedback},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={0, 1},
#>     limitations={},
#>     description={Set to 0 to shut off the crud thermal resistance effect on the rod internal temperaure calculation.
#>                  Note that the crud thermal resistance will still affect the corrosion growth calculation.
#>                  Defaults to 1. },
#>     notes={}
#>   }
  crud_dT_feedback:
    <<: *dtword
    _content:
    _check:
      - is_int()
      - in_dictionary() 0 1

#>
#>   {\bf cicada_outer_radial_zone_num_cells_r} cicada_outer_radial_zone_num_cells_r
#>   \VERAInputTable{
#>     name={cicada_outer_radial_zone_num_cells_r},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={100},
#>     valuesapplicable={>=1},
#>     limitations={},
#>     description={Sets the number of rings in the oxide region of the clad for Cicada runs.  Only
#>        applicable when Cicada used as the crud tool.  Only applicable when cicada_dimension=3.},
#>     notes={}
#>   }
  cicada_outer_radial_zone_num_cells_r:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf cicada_inner_radial_zone_num_cells_r} cicada_inner_radial_zone_num_cells_r
#>   \VERAInputTable{
#>     name={cicada_inner_radial_zone_num_cells_r},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={20},
#>     valuesapplicable={>=1},
#>     limitations={},
#>     description={Sets the number of rings in the clad region of the clad for Cicada runs.  Only
#>        applicable when Cicada used as the crud tool.  Only applicable when cicada_dimension=3.},
#>     notes={}
#>   }
  cicada_inner_radial_zone_num_cells_r:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf cicada_outer_radial_zone_thickness} cicada_outer_radial_zone_thickness
#>   \VERAInputTable{
#>     name={cicada_outer_radial_zone_thickness},
#>     type={float},
#>     need={Optional},
#>     unitsdefault={m},
#>     unitsother={},
#>     valuedefault={100e-6},
#>     valuesapplicable={>0.0},
#>     limitations={},
#>     description={Sets the thickness of the oxide modeling region of the clad.  Only applicable for
#>        crud simulations where Cicada is being used as the modeling tool.  Only applicable when cicada_dimension=3.},
#>     notes={}
#>   }
  cicada_outer_radial_zone_thickness:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf cicada_dimensions} cicada_dimension
#>   \VERAInputTable{
#>     name={cicada_dimensions},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1},
#>     valuesapplicable={1 3},
#>     limitations={},
#>     description={Chooses the dimensions of the clad/oxide conduction solution in Cicada.  Only applicable
#>        when doing a crud simulation using Cicada as the crud tool.  Can either be 1 for radial conduction
#>        only or 3 for radial/axial/azimuthal conduction.},
#>     notes={}
#>   }
  cicada_dimensions:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 1 3
#>
#>   {\bf enable_corrosion_lithium} enable_corrosion_lithium
#>   \VERAInputTable{
#>     name={enable_corrosion_lithium},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={0},
#>     valuesapplicable={0 1},
#>     limitations={},
#>     description={Set to 1 to turn on the lithium effect on clad corrosion.  Only has an effect when modeling
#>        a crud simulation using MAMBA as the crud code.},
#>     notes={}
#>   }
  enable_corrosion_lithium:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 0 1
#>
#>   {\bf crud_details} crud_details
#>   \VERAInputTable{
#>     name={crud_details},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={0},
#>     valuesapplicable={0 1},
#>     limitations={},
#>     description={Set to 1 to turn on additional edits to the VERA-CS HDF5 file related to the crud simulation.},
#>     notes={}
#>   }
  crud_details:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 0 1
#>
#>   {\bf rod_details} rod_details
#>   \VERAInputTable{
#>     name={rod_details},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={0},
#>     valuesapplicable={0 1},
#>     limitations={},
#>     description={Set to 1 to turn on additional edits to the VERA-CS HDF5 file related to the rod solution.},
#>     notes={}
#>   }
  rod_details:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 0 1
#>
#>   {\bf oxide\_thermal\_conductivity} oxide\_thermal\_conductivity
#>   \VERAInputTable{
#>     name={oxide\_thermal\_conductivity},
#>     type={double},
#>     need={Optional},
#>     unitsdefault={W/cm/K},
#>     unitsother={},
#>     valuedefault={1.5},
#>     valuesapplicable={Greater than or equal to 0.0},
#>     limitations={},
#>     description={The thermal conductivity of the clad oxide layer},
#>     notes={}
#>   }

  oxide_thermal_conductivity:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_geq() 0.0

#>   {\bf clad_corrosion_model} clad_corrosion_model
#>   \VERAInputTable{
#>     name={clad_corrosion_model},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1},
#>     valuesapplicable={1 2 3},
#>     limitations={},
#>     description={Selects the corrosion model to use.  The corrosion model is based on the clad material.  Options include:
#>        1 - Zirc 4
#>        2 - M5
#>        3 - ZIRLO
#>     notes={}
#>   }
  clad_corrosion_model:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 1 2 3
#>
#>   {\bf trans_dnb} trans_dnb
#>   \VERAInputTable{
#>     name={trans_dnb},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={0},
#>     valuesapplicable={0 1},
#>     limitations={},
#>     description={Set to 1 to enable the transient CHF model.  Only applicable for transients.},
#>     notes={}
#>   }
  trans_dnb:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 0 1
#>
#>   {\bf cross_flow} cross_flow
#>   \VERAInputTable{
#>     name={cross_flow},
#>     type={int},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1},
#>     valuesapplicable={0 1},
#>     limitations={},
#>     description={Set to 0 to shut off lateral cross flow in CTF.},
#>     notes={}
#>   }
  cross_flow:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - in_dictionary() 0 1

  micro_zaids:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==2

  micro_rxns:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==2


COUPLING:

  epsk:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0

  epsp:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0

  eps_temp:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0

  ctf_iters_max:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0

  ctf_iters_growth:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0

  eps_boron:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0

  rlx_power:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
      - is_leq() 1.0

  rlx_tfuel:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
      - is_leq() 1.0

  rlx_den:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
      - is_leq() 1.0

  maxiter:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0

  read_restart:
    <<: *dtstring
    _content:
    _check:
      - is_string()

TIAMAT:

  solver:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() jacobi gauss-seidel

  run_transient:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false

  two_level_solver:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false

  inner_solver:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() jacobi gauss-seidel

  inner_evaluator:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() BisonNeutronics BisonCTF NeutronicsCTF

  conserve_power_in_tiamat_transfer:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false

  num_subcycle_iterations_before_tiamat_ramping:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() -1

  coupling_approach:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() coupled inline

  overlap_procs:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false

#>
#> \section{Block MPACT}
#> \label{sec:mpactcards}
MPACT:

#>
#>   {\bf transport\_method} transport\_method
#>   \VERAInputTable{
#>     name={transport\_method},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={MOC},
#>     valuesapplicable={},
#>     limitations={},
#>     description={This card is used to specify whether Method of Characteristics or    %
#>       Sn transport methods are used for the global problem solution method.},
#>     notes={}
#>   }
  transport_method:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() MOC Sn
#>
#>   {\bf sn\_numcart} sn\_numcart
#>   \VERAInputTable{
#>     name={sn\_numcart},
#>     type={Integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1},
#>     valuesapplicable={},
#>     limitations={},
#>     description={This card is used to specify the number of X and Y sub-divisions     %
#>       in which to divide each pincell into for the Sn Transport sweeper.},
#>     notes={}
#>   }
  sn_numcart:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf ray\_spacing} ray\_spacing
#>   \VERAInputTable{
#>     name={ray\_spacing},
#>     type={Floating-Point Real Number},
#>     need={Optional},
#>     unitsdefault={cm},
#>     unitsother={},
#>     valuedefault={0.05},
#>     valuesapplicable={Positive floating-point real numbers},
#>     limitations={},
#>     description={This card is used to specify the characteristic ray spacing          %
#>       for the rays used in the MOC calculation.  A finer spacing will permit a        %
#>       more-detailed calculation (with finer spatial features) at the cost of          %
#>       computing time.  However, the decomposition of rays across multiple threads     %
#>       parallelizes very efficiently.  Finally, one should be cognizant of             %
#>       minimum feature size (i.e., minimum flat-source region size) to ensure          %
#>       that there are an adequate number of rays traversing each region to             %
#>       have an accurate solution in that region.  More information regarding           %
#>       the MOC methodology and implications of \texttt{ray\_spacing} on the            %
#>       overall calculation is available in the MPACT Theory Manual.},
#>     notes={}
#>   }
  ray_spacing:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf shield\_ray\_spacing} shield\_ray\_spacing
#>   {\bf shield\_ray\_spacing} shield\_ray\_spacing
#>   \VERAInputTable{
#>     name={shield\_ray\_spacing},
#>     type={Floating-Point Real Number},
#>     need={Optional},
#>     unitsdefault={cm},
#>     unitsother={},
#>     valuedefault={0.05},
#>     valuesapplicable={Positive floating-point real numbers},
#>     limitations={},
#>     description={This card is used to specify the characteristic ray spacing          %
#>       for the rays used in the MOC sheidling calculation.  A finer spacing will       %
#>       permit a more-detailed calculation (with finer spatial features) at the cost of %
#>       computing time.  However, the decomposition of rays across multiple threads     %
#>       parallelizes very efficiently.  Finally, one should be cognizant of             %
#>       minimum feature size (i.e., minimum flat-source region size) to ensure          %
#>       that there are an adequate number of rays traversing each region to             %
#>       have an accurate solution in that region.  More information regarding           %
#>       the MOC methodology and implications of \texttt{ray\_spacing} on the            %
#>       overall calculation is available in the MPACT Theory Manual.},
#>     notes={}
#>   }
  shield_ray_spacing:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
  log_message:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() debug warn basic
  refl_no_added_modules:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() true false
  refl_highres:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() true false
#>
#>   {\bf moc\_kernel} moc\_kernel
#>   \VERAInputTable{
#>     name={moc\_kernel},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={MG},
#>     valuesapplicable={},
#>     limitations={},
#>     description={This card is used to specify whether one-group or multi-group        %
#>       MOC kernels are used.},
#>     notes={}
#>   }
  moc_kernel:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() 1g mg 1G MG kokkos
#>
#>   {\bf shield\_moc\_kernel} shield\_moc\_kernel
#>   \VERAInputTable{
#>     name={shield\_moc\_kernel},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={same value as moc\_kernel},
#>     valuesapplicable={},
#>     limitations={},
#>     description={This card is used to specify whether one-group or multi-group        %
#>       MOC kernels are used for the shielding sweeper.},
#>     notes={}
#>   }
  shield_moc_kernel:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() 1g mg 1G MG
#>
#>   {\bf moc\_mg\_data\_passing} moc\_mg\_data\_passing
#>   \VERAInputTable{
#>     name={moc\_mg\_data\_passing},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={true},
#>     valuesapplicable={false},
#>     limitations={},
#>     description={This card is used to specify whether one-group or multi-group        %
#>       MOC data passing is used.},
#>     notes={This is primarily to bypass the MPI issues observed with MGAngFlux and     %
#>            is only applicable when using moc\_kernel=MG.}
#>   }
  moc_mg_data_passing:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf volume\_corr} volume\_corr
#>   \VERAInputTable{
#>     name={volume\_corr},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={INTEGRAL},
#>     valuesapplicable={},
#>     limitations={},
#>     description={This card is used to specify the volume correction being applied   %
#>       to the MOC segments.},
#>     notes={}
#>   }
  volume_corr:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() none angledep integral NONE ANGLEDEP INTEGRAL
#>
#>   {\bf modular\_rays} modular\_rays
#>   \VERAInputTable{
#>     name={modular\_rays},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={TWO},
#>     valuesapplicable={},
#>     limitations={},
#>     description={This card is used to specify the volume correction being applied   %
#>       to the MOC segments.},
#>     notes={}
#>   }
  modular_rays:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() decart two three cactus ratfrac DECART TWO THREE CACTUS RATFRAC
  radial_src_order:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_geq() 0
  axial_src_order:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_geq() 0
  power_edit:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() fission FISSION kappa-fission KAPPA-FISSION gamma-smeared GAMMA-SMEARED
#>
#>   {\bf jagged} jagged
#>   \VERAInputTable{
#>     name={jagged},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={true},
#>     valuesapplicable={false},
#>     limitations={See Notes regarding potential inefficiencies when running            %
#>       a parallel-processing simulation.},
#>     description={This card is used to specify whether the reflector region            %
#>       will be  modeled using a jagged (stair-step) representation or by               %
#>       filling the full square extent of the modeling domain with moderator            %
#>       material.},
#>     notes={When a jagged core is used, care should be taken if the user elects        %
#>       to perform manual parallel domain decomposition to ensure proper load           %
#>       balancing.  Additional information is available regarding this is               %
#>       provided with the \texttt{par\_file}.}
#>   }
  jagged:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf rod\_treatment} rod\_treatment
#>   \VERAInputTable{
#>     name={rod\_treatment},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={none},
#>     valuesapplicable={polynomial,1dcpm},
#>     limitations={The pre-generated polynomials were generated using AIC, B4C,         %
#>       and Tungsten control rods for Watts Bar Unit 1.  Materials with any other       %
#>       name will be ignored, and the results may not be improved as much for           %
#>       reactors other than Watts Bar Unit 1.},
#>     description={This card toggles the use of volume-weighting for control            %
#>       rods in order to minimize the effect of control rod cusping on the              %
#>       calculated results.
#>       \newline\newline
#>       Rod cusping is a calculational effect that occurs when a control rod is         %
#>       partially inserted into a calculational plane.  This causes an                  %
#>       artificial reduction in the local flux which in turn causes an error in         %
#>       the calculated eigenvalue and global power distribution.  Enabling this         %
#>       rod treatment card will correct for these effects.  The polynomial option       %
#>       uses pre-generated polynomials to reduce the volume fraction of the control     %
#>       rod material during the homogenization step, providing better solutions         %
#>       near the tip of the control rod.  The 1dcpm method uses the 1d collision        %
#>       probabilities method to generate radial shape functions for rodded and          %
#>       unrodded regions, then uses these shape functions to flux-volume homogenize     %
#>       the cross-sections for the MOC calculations.},
#>     notes={This card only has an effect when used in a 3D calculation (i.e.,          %
#>       a calculation with axial planes).  Options other than none and polynomial       %
#>       require that one of \texttt{subplane\_max}, \texttt{subplane\_target}, or         %
#>       \texttt{num\_subplanes} be used as well. All options requiring subplane          %
#>       to be enabled are considered experimental.}
#>   }
  rod_treatment:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() none polynomial 1dcpm 2dmoc subplane true false
  ppm_method:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() 1 2
  valid_on:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
  valid_delim:
    <<: *dtstring
    _content:
    _check:
      - is_string()
#>
#>   {\bf checkpoint\_mode} checkpoint\_mode
#>   \VERAInputTable{
#>     name={checkpoint\_mode},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={I},
#>     valuesapplicable={T, F, R, W, RW which correspond to:                             %
#>       \begin{itemize}                                                                 %
#>         \item \texttt{I} --- specifies that a checkpoint file may be written          %
#>           through a user interrupt.                                                   %
#>         \item \texttt{T} --- specifies that the case will be started from a           %
#>           checkpoint file.                                                            %
#>         \item \texttt{F} --- disables initialization of the checkpoint file.          %
#>         \item \texttt{R} --- same as T.                                               %
#>         \item \texttt{W} --- specifies that a checkpoint file is to be                %
#>           written.                                                                    %
#>         \item \texttt{RW} --- same as T and R but after the checkpoint file           %
#>           is read it can be overwritten during the calculation.                       %
#>       \end{itemize}},
#>     limitations={File system permissions must be configured such that MPACT           %
#>       can interact with files, as needed.},
#>     description={This card is used to control whether the calculation is              %
#>       restarted from a checkpoint file.                                               %
#>       \newline\newline                                                                %
#>       The user can send the interrupt signal to MPACT after execution has             %
#>       begun by creating a file named ``MPACT\_CHECKPOINT\_FILE'' in the               %
#>       simulation's working directory. The existence of this file causes a             %
#>       checkpoint file to be written after every outer iteration. Likewise,            %
#>       the removal of ``MPACT\_CHECKPOINT\_FILE'' disables the writing of a            %
#>       checkpoint file.                                                                %
#>       \newline\newline                                                                %
#>       See the \texttt{checkpoint\_file} card regarding checkpoint file                %
#>       naming.},
#>     notes={}
#>   }
  checkpoint_mode:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() T F W R RW
#>
#>   {\bf checkpoint\_file} checkpoint\_file
#>   \VERAInputTable{
#>     name={checkpoint\_file},
#>     type={Free-form Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={\texttt{<CASEID>}.mcp},
#>     valuesapplicable={},
#>     limitations={The filename must be specified with characters valid for use         %
#>       on the computer system being executed on.  As a general practice, one           %
#>       should avoid the use of "special" characters.  Similarly, one must not          %
#>       specify a name that conflicts with other files that are (or will be)            %
#>       created within the MPACT directory.},
#>     description={If a checkpoint file will be used, then the user can                 %
#>       optionally specify the name of this file of his or her choosing.},
#>     notes={There is no strict limit on how many characters can be used to             %
#>       to specify the filename; however, good judgment should be used to               %
#>       keep the filename a reasonable length.}
#>   }
  checkpoint_file:
    <<: *dtword
    _content:
    _check:
      - is_word()
#>
#>   {\bf rst\_compress} rst\_compress
#>   \VERAInputTable{
#>     name={rst\_compress},
#>     type={Free-form Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={5},
#>     valuesapplicable={none and 0 through 9. "None" means the HDF5 Filter for%
#>       gzip compression is NOT used when writing the restart file. The       %
#>       numeric value indicates the level of compression to use in gzip. The  %
#>       higher the number, the more aggressive the compression and the more   %
#>       resources used. See documentation of gzip for information.},
#>     limitations={This only affects the WRITING of the restart file.         %
#>       \texttt{restart\_read} cases and texttt{restart\_shuffle} cases are   %
#>       not affected.}
#>     notes={The primary reason for this option is to disable compression     %
#>       because on some platforms decompression by HDF5 while reading may     %
#>       lead to an allocation error in HDF5 due to heap fragmentation. See    %
#>       documentation on the h5repack utility installed with the HDF5 library %
#>       for removing compression after the file is written. e.g.              %
#>       \texttt{h5repack -f NONE <old\_file> <new\_file>}}
#>   }
  rst_compress:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() none 0 1 2 3 4 5 6 7 8 9
#>
#>   {\bf vis\_edits} vis\_edits
#>   \VERAInputTable{
#>     name={vis\_edits},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={core},
#>     valuesapplicable={none, fsr. These are described as:                              %
#>       \begin{enumerate}                                                               %
#>         \item \texttt{core} --- will print pin level edits of power for the           %
#>           full core                                                                   %
#>         \item \texttt{none} --- will not print any visualization files                %
#>         \item \texttt{fsr} --- will print all available edits in the code on          %
#>           a flat source region-basis which includes material boundaries, mesh         %
#>           identification indices, and group-wise scalar flux                          %
#>       \end{enumerate}},
#>     limitations={},
#>     description={This card is used to specify the type of visualization a             %
#>       outputs (edits).  The visualization outputs are created in the form of          %
#>       the VTK legacy file format which is suitable for use with VisIt                 %
#>       (\url{https://wci.llnl.gov/simulation/computer-codes/visit/}), or other         %
#>       suitable programs capable of reading the format.},
#>     notes={The FSR edits will be very large and may consume considerable time         %
#>       to generate the visualization files.}
#>   }
  vis_edits:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() none core fsr fsrvtu
#>
#>   {\bf rr\_edits} rr\_edits
#>   \VERAInputTable{
#>     name={rr\_edits},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={none},
#>     valuesapplicable={hdf5, out, both. These are described as:                        %
#>       \begin{enumerate}                                                               %
#>         \item \texttt{none} --- will not generate reaction rate edits                 %
#>         \item \texttt{hdf5} --- will generate reaction rate edits in hdf5             %
#>         \item \texttt{out} --- will print reaction rate in the output file            %
#>         \item \texttt{both} --- will do both \texttt{hdf5} and \texttt{out}            %
#>       \end{enumerate}},
#>     limitations={},
#>     description={This card is used to specify the type of reaction rate               %
#>       outputs (edits).  The reaction rate of an isotope is currently smeared          %
#>       over the problem domain when being printed to the output file, but the          %
#>       hdf5 file contains full information of reaction rates in geometry mesh.},
#>     notes={The reaction rate edits could be slow and memory-consuming for         %
#>       a large problem.}
#>   }
  rr_edits:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() none hdf5 out both
#>
#>   {\bf rr\_edits\_opt} rr\_edits\_opt
#>   \VERAInputTable{
#>     name={rr\_edits\_opt},
#>     type={Array of Pre-defined Format Strings},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={none},
#>     valuesapplicable={The user specified isotope and reaction pairs in a format \texttt{isotope\_reaction}.},
#>     limitations={This card can only be used if \texttt{rr\_edits} is turned on.},
#>     description={This card is used to specify the reaction rate edits for user-specified       %
#>                  isotopes and reactions. The \texttt{isotope} is in a format of xx-AAA,        %
#>                  e.g., U-235 and Pu-239. The available reaction types are \texttt{absorption}, %
#>                  \texttt{fission}, \texttt{nu*fission}, \texttt{inscatter},\texttt{outscatter} %
#>                  and \texttt{selfscatter}.},
#>     notes={Select the important isotopes and reactions for edits can reduce the computing time %
#>            and memory requirements for a large problem.}
#>   }
  rr_edits_opt:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_word(shift)},())
#>
#>   {\bf xe135m\_opt} xe135m\_opt
#>   \VERAInputTable{
#>     name={xe135m\_opt},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={ignore},
#>     valuesapplicable={ignore, combine, explicit. These are described as:              %
#>       \begin{enumerate}                                                               %
#>         \item \texttt{ignore} --- will ignore Xe-135m in transport calculation        %
#>         \item \texttt{combine} --- will combine Xe-135m into Xe-135 in transport calculation %
#>         \item \texttt{explicit} --- will treat Xe-135m explicitly as other isotopes in transport calculation  %
#>       \end{enumerate}},
#>     limitations={},
#>     description={This card is used to specify the treatment of Xe-135m. %
#>     By default, MPACT ignores Xe-135m when performing transport calculation          %
#>     although depletion solver may consider it. When combining Xe-135m into Xe-135,          %
#>     cross sections of the two isotopes are assumed the same. Explicit treatment can be
#>     enabled only for the latest MG library that has Xe-135m data based
#>     on TENDL data.},
#>     notes={}
#>   }
  xe135m_opt:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() ignore combine explicit
  nodal_edits:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf grid\_treatment} grid\_treatment
#>   \VERAInputTable{
#>     name={grid\_treatment},
#>    type={Fixed Character String},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={\texttt{homogenize}},
#>    valuesapplicable={\texttt{equal\_mass}, \texttt{equal\_thickness}                  %
#>      \begin{itemize}                                                                  %
#>        \item \texttt{homogenize} --- will take the mass specified in the              %
#>          grid card, calculate the moderator volume of the lattice where the           %
#>          grid is located, and use the two values to compute the density of            %
#>          the material.  This option applies the grid material uniformly               %
#>          throughout the lattice.                                                      %
#>        \item \texttt{equal\_thickness} --- uses the grid mass and the                 %
#>          corresponding grid material density to compute the total grid                %
#>          volume for that lattice.  The volume is then used to determine the           %
#>          thickness the grid would be within each pincell, and is modeled as           %
#>          an additional rectangular mesh around the perimeter of each pin cell         %
#>          in the lattice.                                                              %
#>        \item \texttt{equal\_mass} --- similar to the \texttt{equal\_thickness}        %
#>          option, except that the thickness of the grid in each pin cell is            %
#>          changed throughout the lattice so that every pin cell has the same           %
#>          grid material mass in it.                                                    %
#>      \end{itemize}},
#>    limitations={For grids with a large mass that fall in a narrow (axially)           %
#>      lattice, there is a possibility that the grid will intersect one or more         %
#>      pins for the \texttt{equal\_thickness} and \texttt{equal\_mass} options.         %
#>      If this event occurs, MPACT will raise an error, and the user will need to       %
#>      change the axial meshing options, change the geometry of the lattice, or         %
#>      simply use the \texttt{homogenize} option for the \texttt{grid\_treatment}       %
#>      card.},
#>    description={This card is used to indicate the method of applying the              %
#>      grid structure in a lattice on the mesh.},                                       %
#>    notes={}
#>   }
  grid_treatment:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() homogenize equal_mass equal_thickness
  axial_buckling:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
#>
#>   {\bf uniform\_crud} uniform\_crud
#>   \VERAInputTable{
#>     name={uniform\_crud},
#>     type={Floating-Point Real Numbers},
#>     need={Optional},
#>     unitsdefault={microns, mg/cm$^2$, mg/cm$^2$},
#>     unitsother={},
#>     valuedefault={0.0, 0.0, 0.0},
#>     valuesapplicable={},
#>     limitations={},
#>     description={This card is used to define a uniform layer of CRUD on all           %
#>       fuel pins. The \texttt{thickness} is the CRUD thickness in microns,             %
#>       the \texttt{crud\_mass} is the surface mass density of  Ni Fe$_2$              %
#>       O$_4$ in mg/cm$^2$, and the \texttt{boron\_mass} is the surface mass            %
#>       density of  Li B$_4$ O$_7$ in mg/cm$^2$.},
#>     notes={}
#>   }
  uniform_crud:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==3
      - is_float(nth(0,()))
      - is_float(nth(1,()))
      - is_float(nth(2,()))
      - nth(0,())>=0
      - nth(1,())>=0
      - nth(2,())>=0
  crud_depletion:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==2
      - is_word(nth(0,()))
      - is_float(nth(1,()))
      - in_dictionary(nth(0,()),'true','false')
      - nth(1,())>=0
#>
#>   {\bf meshing\_method} meshing\_method
#>   \VERAInputTable{
#>     name={meshing\_method},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={\texttt{useraxialmesh} (axial\_mesh card present) \emph{or}         %
#>       \texttt{matbound} (axial\_mesh card not present)},
#>     valuesapplicable={\texttt{nonfuel}, \texttt{all}                                  %
#>       \newline\newline                                                                %
#>       \begin{itemize}                                                                 %
#>         \item \texttt{useraxialmesh} --- Requires the use of the                      %
#>           axial mesh card and no auto meshing is performed in this instance.          %
#>           This option will not use the values specified by the                        %
#>           \texttt{automesh\_bounds} since it does not do any automeshing.             %
#>         \item \texttt{matbound} --- Calculates the axial mesh                         %
#>           just at the axial material boundaries of the problem and uses the           %
#>           \texttt{axial\_edit\_bounds} as the mesh within the fuel regions.           %
#>           No further meshing is performed. This option will not use the               %
#>           values specified by the \texttt{automesh\_bounds} since it does not         %
#>           do any automeshing.                                                         %
#>         \item \texttt{nonfuel} --- Will take the material                             %
#>           boundaries and automesh the regions below and above the fuel. The           %
#>           minimum and maximum bounds (or default values) specified by the             %
#>           \texttt{automesh\_bounds} will be used to determine the sizing.             %
#>         \item \texttt{all} --- Will take the material boundaries                      %
#>           and automesh all regions. The minimum and maximum bounds (or                %
#>           default values) specified by the \texttt{automesh\_bounds} will be          %
#>           used to determine the sizing. When using the \texttt{all} option, fuel      %
#>           regions will not be homogenized with non-fuel regions.  Homogenization      %
#>           will only occur within those regions.                                       %
#>       \end{itemize}},
#>     limitations={Must be set in conjunction with the \texttt{axial\_edit\_bounds}     %
#>       card in the \texttt{EDIT} block of the VERA input when the option is not        %
#>       \texttt{useraxialmesh}. This data is required to set up the axial mesh for      %
#>       every input option except the \texttt{useraxialmesh} where it is separately     %
#>       specified.},
#>     description={This card specifies the type of axial meshing to be used.            %
#>       If this card is not present, the method will default to \texttt{useraxialmesh}  %
#>       if the \texttt{axial\_mesh} card is present or it will default to               %
#>       \texttt{matbound} if the \texttt{axial\_mesh} card is not present.},
#>     notes={When using the \texttt{useraxialmesh} option, it is possible to            %
#>       specify a mesh that does not conform or align with the problem's                %
#>       geometry.  Warnings will be printed to the log file stating that the            %
#>       mesh does not match the geometry boundaries and those regions will be           %
#>       homogenzied.}
#>   }
  meshing_method:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() useraxialmesh matbound nonfuel all
#>
#>   {\bf automesh\_bounds} automesh\_bounds
#>   \VERAInputTable{
#>     name={automesh\_bounds},
#>     type={Array of Floating-Point Real Numbers, Length = 2},
#>     need={Optional},
#>     unitsdefault={cm},
#>     unitsother={},
#>     valuedefault={2.0 10.0, when automeshing is enabled.},
#>     valuesapplicable={Positive real numbers greater than zero.  The maximum value     %
#>        must be at least 1.0 greater than the minimum value.},
#>     limitations={},
#>     description={This card specifies the minimum and  maximum desired axial           %
#>       mesh for the auto axial meshing. Any geometry or mesh region larger             %
#>       than the specified value will be broken up into smaller mesh regions            %
#>       that have a height between the maximum and minimum values. Any                  %
#>       geometry or mesh region smaller than the specified value will be                %
#>       homogenized and added to a neighboring mesh region until the value is           %
#>       above the minimum and below the maximum.},
#>     notes={The region where these values are applied is specified by the              %
#>       \texttt{meshing\_method} card.  This card is ignored when the                   %
#>       \texttt{useraxialmesh} and \texttt{matbound} method is specified.               %
#>       \newline\newline                                                                %
#>       It should also be noted that specifying min and max values that are             %
#>       close together will most likely result in more axial homogenization             %
#>       than may be desired by the user.  It would mean that most of the                %
#>       material interfaces will be homogenzied to some degree.                         %
#>       \newline\newline                                                                %
#>       Also, this routine in no way optimizes the axial meshing for a given            %
#>       problem.  It is primarily designed to reduce user burden from                   %
#>       specifying a typically troublesome input parameter. It is best suited for       %
#>       problems with a large number of planes that vary in thickness.  It is also      %
#>       useful for setting a problem up, if the user is unsure about the axial          %
#>       discretization.  Using this card will save time spent on recalculating          %
#>       values whenever the axial mesh needs to be adjusted. }
#>   }
  automesh_bounds:
    <<: *dtlist
    _content:
    _check:
      - nth(0,())>0
      - nth(1,())>0
#>
#>   {\bf axial\_mesh} axial\_mesh
#>   \VERAInputTable{
#>     name={axial\_mesh},
#>    type={Array of Floating-Point Real Numbers, Length = User Specified},
#>    need={Optional},
#>    unitsdefault={cm},
#>    unitsother={},
#>    valuedefault={N/A},
#>    valuesapplicable={Array of positive real numbers.},
#>    limitations={The sum of the values specified within this card must be              %
#>      equal to the total geometric height of the problem.},
#>    description={This card is used to specify the axial mesh used in the 2-D/1-D       %
#>      simulation.  The input is the thickness of each axial section the user           %
#>      wishes to model.  This card is optional if the \texttt{meshing\_method}          %
#>      card specifies an option other than \texttt{useraxialmesh}. If the               %
#>      \texttt{meshing\_method} is \texttt{useraxialmesh}, then it is required.},
#>    notes={If the array of axial meshes sums to less than the problem height,          %
#>      the geometry at the top will be truncated.  If it sums to more than the          %
#>      problem height, the top geometry will be extended all the way to the upper       %
#>      mesh height.  Therefore, it is very important to make sure the axial mesh        %
#>      is specified in accordance with the geometry.}
#>   }
  axial_mesh:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_float(shift)},())
#>
#>   {\bf pin\_cell\_mod\_mesh} pin\_cell\_mod\_mesh
#>   \VERAInputTable{
#>     name={pin\_cell\_mod\_mesh},
#>     type={Array of mixed types int and string, Length = 2},
#>     need={Optional},
#>     unitsdefault={cm},
#>     unitsother={},
#>     valuedefault={\texttt{max\_radii} = \texttt{0.75*(pitch*0.5 - r\_last)+r\_last},  %
#>       \texttt{num\_rings} = 1, and \texttt{pin\_cell\_type} = fuel},
#>     valuesapplicable={                                                                %
#>       \begin{itemize}                                                                 %
#>         \item \texttt{num\_rings} --- positive integers. Practially less than 10.     %
#>         \item \texttt{pin\_cell\_type} --- "fuel", "nonfuel", "both".                 %
#>       \end{itemize}},
#>     limitations={This option does not work with explicit grid spacers. To use with    %
#>       grid spacers set the \texttt{grid\_treatment} option to \texttt{homogenize}.},
#>     description={This card is used to specify the MOC flat source region mesh         %
#>       in moderator outside the defined cylindrical geometry in specified pin cells.   %
#>       The radius of the outermost moderator ring is fixed at 0.95*sqrt(2)/2*pitch %
#>       This gives more refined meshing in the pin cell corners which improves accuracy %
#>       of calculations at room temperature},
#>     notes={}
#>   }
  pin_cell_mod_mesh:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==2
      - is_int(nth(0,()))
      - is_word(nth(1,()))
      - nth(0,())>0
      - in_dictionary(nth(1,()),'fuel','nonfuel','both')
#>
#>   {\bf crud\_mesh} crud\_mesh
#>   \VERAInputTable{
#>     name={crud\_mesh},
#>     type={One Floating-Point Real and One Integer},
#>     need={Optional},
#>     unitsdefault={microns},
#>     unitsother={},
#>     valuedefault={N/A},
#>     valuesapplicable={Positive real numbers for \texttt{max\_rad} and integers        %
#>       greater than 0 for \texttt{num\_rad}. The \texttt{max\_rad} is the maximum      %
#>       thickness of the outermost CRUD region in microns and \texttt{num\_rad}         %
#>       is the number of radial subdivisions in the CRUD region.},
#>     limitations={},
#>     description={This card is used to specify the radial mesh that is                 %
#>       added for each cell to account for CRUD build-up on the surface                 %
#>       of the fuel pins.},
#>     notes={}
#>   }
  crud_mesh:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==2
      - is_float(nth(0,()))
      - is_int(nth(1,()))
      - nth(0,())>0
      - nth(1,())>0
#>
#>   {\bf quad\_type} quad\_type
#>   \VERAInputTable{
#>     name={quad\_type},
#>     type={Fixed Character String},
#>     need={Required},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={None},
#>     valuesapplicable={listed below                                                    %
#>       \newline \newline                                                               %
#>       \begin{tabular}{llll}                                                           %
#>         \hline                                                                        %
#>           Quadrature Name & Type & Order & Order $\Theta$ \\                          %
#>         \hline                                                                        %
#>           \texttt{CHEBYSHEV-CHEBYSHEV} & Product & integers > 0             & integers > 0       \\ %
#>           \texttt{CHEBYSHEV-GAUSS    } & Product & integers > 0             & integers > 0       \\ %
#>           \texttt{CHEBYSHEV-BICKLEY  } & Product & integers > 0             & 1, 2, 3, or 4      \\ %
#>           \texttt{CHEBYSHEV-YAMAMOTO } & Product & integers > 0             & 1, 2, or 3         \\ %
#>           \texttt{LEVEL-SYMMETRIC    } & General & even integers in [2,16]  & N/A                \\ %
#>           \texttt{QUADRUPLE-RANGE    } & Product & integers in [1,37]       & integers in [1,18] \\ %
#>         \hline                                                                        %
#>       \end{tabular}},
#>     limitations={},
#>     description={This card is used to specify the name of the angular                 %
#>       quadrature to use for determining the angles at which the rays are              %
#>       traced throughout the problem.},
#>     notes={None}
#>   }
  quad_type:
    <<: *dtword
    _content:
    _check:
      - is_word()
#>
#>   {\bf shield\_quad\_type} shield\_quad\_type
#>   \VERAInputTable{
#>     name={shield\_quad\_type},
#>     type={Fixed Character String},
#>     need={Required},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={None},
#>     valuesapplicable={listed below                                                    %
#>       \newline \newline                                                               %
#>       \begin{tabular}{llll}                                                           %
#>         \hline                                                                        %
#>           Quadrature Name & Type & Order & Order $\Theta$ \\                          %
#>         \hline                                                                        %
#>           \texttt{CHEBYSHEV-CHEBYSHEV} & Product & integers > 0             & integers > 0       \\ %
#>           \texttt{CHEBYSHEV-GAUSS    } & Product & integers > 0             & integers > 0       \\ %
#>           \texttt{CHEBYSHEV-BICKLEY  } & Product & integers > 0             & 1, 2, 3, or 4      \\ %
#>           \texttt{CHEBYSHEV-YAMAMOTO } & Product & integers > 0             & 1, 2, or 3         \\ %
#>           \texttt{LEVEL-SYMMETRIC    } & General & even integers in [2,16]  & N/A                \\ %
#>           \texttt{QUADRUPLE-RANGE    } & Product & integers in [1,37]       & integers in [1,18] \\ %
#>         \hline                                                                        %
#>       \end{tabular}},
#>     limitations={},
#>     description={This card is used to specify the name of the angular                 %
#>       quadrature to use for determining the angles at which the rays are              %
#>       traced throughout the problem for the shielding calculation.},
#>     notes={None}
#>   }
  shield_quad_type:
    <<: *dtword
    _content:
    _check:
      - is_word()
#>
#>   {\bf azimuthals\_octant} azimuthals\_octant
#>   \VERAInputTable{
#>     name={azimuthals\_octant},
#>     type={Integer},
#>     need={Required},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={None},
#>     valuesapplicable={Column Order in the above table},
#>     limitations={},
#>     description={This card is used to specify the number of azimuthal angles          %
#>       per octant and corresponds to the Order column in the table in                  %
#>       \texttt{quad\_type} card.},
#>     notes={None}
#>   }
  azimuthals_octant:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf polars\_octant} polars\_octant
#>   \VERAInputTable{
#>     name={polars\_octant},
#>     type={Integer},
#>     need={Required},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={None},
#>     valuesapplicable={Column Order $\Theta$ in the above table},
#>     limitations={},
#>     description={This card is used to specify the number of polar angles per          %
#>       octant and corresponds to the Order $\Theta$ column in the quadrature           %
#>       table specified in \texttt{quad\_type} card. Note the number of polar angles    %
#>       may be limited by the quadrature type used. Also, any non-product quadrature    %
#>       types will not use this input card (i.e., in the only applicable case           %
#>       \texttt{LEVEL-SYMMETRIC}).},
#>     notes={None}
#>   }
  polars_octant:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf shield\_azimuthals\_octant} shield\_azimuthals\_octant
#>   \VERAInputTable{
#>     name={shield\_azimuthals\_octant},
#>     type={Integer},
#>     need={Required},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={None},
#>     valuesapplicable={Column Order in the above table},
#>     limitations={},
#>     description={This card is used to specify the number of azimuthal angles          %
#>       per octant for the shielding sweeper and corresponds to the Order column        %
#>       in the table in \texttt{quad\_type} card.},
#>     notes={None}
#>   }
  shield_azimuthals_octant:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf polars\_octant} polars\_octant
#>   \VERAInputTable{
#>     name={polars\_octant},
#>     type={Integer},
#>     need={Required},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={None},
#>     valuesapplicable={Column Order $\Theta$ in the above table},
#>     limitations={},
#>     description={This card is used to specify the number of polar angles per          %
#>       octant for the shielding calculation and corresponds to the Order $\Theta$      %
#>       column in the quadrature table specified in \texttt{quad\_type} card. Note the  %
#>       number of polar angles may be limited by the quadrature type used. Also, any    %
#>       non-product quadrature types will not use this input card (i.e., in the only    %
#>       applicable case \texttt{LEVEL-SYMMETRIC}).},
#>     notes={None}
#>   }
  shield_polars_octant:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf xs\_type} xs\_type
#>   \VERAInputTable{
#>     name={xs\_type},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={\texttt{NONE}},
#>     valuesapplicable={\texttt{ORNL} or \texttt{SIMPLIFIED\_AMPX}},
#>     limitations={},
#>     description={This card is used to specify the type of cross-section file         %
#>       to use.},
#>     notes={}
#>   }
  xs_type:
    <<: *dtword
    _content:
    _check:
      - is_word()
#>
#>   {\bf xs\_filename} xs\_filename
#>   \VERAInputTable{
#>     name={xs\_filename},
#>     type={Free-Form Character String, Max. Length = 200},
#>     need={Required},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={No default value},
#>     valuesapplicable={filename of a supported cross section library},
#>     limitations={},
#>     description={This card is used to specify the name of the cross-section           %
#>       file to use.},
#>     notes={}
#>   }
  xs_filename:
    <<: *dtword
    _content:
    _check:
      - is_word()
#>
#>   {\bf ce\_filename} ce\_filename
#>   \VERAInputTable{
#>     name={ce\_filename},
#>     type={Free-Form Character String, Max. Length = 200},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={No default value},
#>     valuesapplicable={filename of an indexing file for CE library},
#>     limitations={},
#>     description={This card is used to specify the name of the indexing               %
#>                  file of continuous-energy cross-section library to be               %
#>                  used when \texttt{quasi\_1D} is toggled on.},
#>     notes={}
#>   }
  ce_filename:
    <<: *dtword
    _content:
    _check:
      - is_word()
#>
#>   {\bf shield\_method} shield\_method
#>   \VERAInputTable{
#>     name={shield\_method},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={\texttt{subgroup}},
#>     valuesapplicable={\texttt{essm}},
#>     limitations={The \texttt{xs\_shielder} card must be enabled (default) in          %
#>       order to enable this card, otherwise unshielded cross section                   %
#>       (infinite-dilute) will be used.},
#>     description={This card is used to specify the method used to shield the           %
#>       cross sections.},
#>     notes={In general, \texttt{subgroup} is slower than \texttt{essm}                 %
#>       (by a factor of 2 to 5 depending on the \texttt{subgroup\_set} option).         %
#>       However, subgroup method has a few advantages over ESSM, such                   %
#>       as a better representation of distributed self-shielding within                 %
#>       the fuel and the resonance category treatment (resonance isotopes are grouped   %
#>       into categories). Therefore, subgroup method is an option with better accuracy  %
#>       in the current version.}
#>   }
  shield_method:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() subgroup essm
#>
#>   {\bf shield\_nbatch} shield\_nbatch
#>   \VERAInputTable{
#>     name={shield\_nbatch},
#>     type={Integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={5},
#>     valuesapplicable={},
#>     limitations={},
#>     description={This card is used to specify the number of batches used to           %
#>       divide the pseudogroups of the MG shielding sweeper.},
#>     notes={}
#>   }
  shield_nbatch:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf xs\_shielder} xs\_shielder
#>   \VERAInputTable{
#>     name={xs\_shielder},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={\texttt{true}},
#>     valuesapplicable={\texttt{false},\texttt{t},\texttt{f}},
#>     limitations={},
#>     description={This card is used to specify whether to shield the cross             %
#>       sections or not: \texttt{ture}--enabled, \texttt{false}--disabled},
#>     notes={If shielder is disabled, the infinite-dilute cross sections                %
#>       for the resonance energy groups are used.}
#>   }
  xs_shielder:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() t f true false
#>
#>   {\bf spatial\_essm} spatial\_essm
#>   \VERAInputTable{
#>     name={spatial\_essm},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={\texttt{false}},
#>     valuesapplicable={\texttt{true},\texttt{t},\texttt{f}},
#>     limitations={},
#>     description={This card is used to specify whether to perform the                 %
#>                  spatial essm correction for self-shielding                 %
#>                  calculation. Currently, this option can only be toggled             %
#>                  on with \texttt{essm}.},
#>     notes={}
#>   }
  spatial_essm:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() t f true false
#>
#>   {\bf quasi\_1D} quasi\_1D
#>   \VERAInputTable{
#>     name={quasi\_1D},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={\texttt{false}},
#>     valuesapplicable={\texttt{true},\texttt{t},\texttt{f}},
#>     limitations={},
#>     description={This card is used to specify whether to perform the                 %
#>                  quasi-1D slowing-down correction for self-shielding                 %
#>                  calculation. Currently, this option can only be toggled             %
#>                  on with \texttt{essm}.},
#>     notes={}
#>   }
  quasi_1D:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() t f true false
#>
#>   {\bf res\_up\_scatter} res\_up\_scatter
#>   \VERAInputTable{
#>     name={res\_up\_scatter},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={\texttt{false}},
#>     valuesapplicable={\texttt{true}},
#>     limitations={},
#>     description={This card is used to specify whether to use the resonance           %
#>                  data that incoporates the epithermal upscattering model.            %
#>                  Currently, this option is only supported for ORNL library           %
#>                  from version 4 and thereafter.},
#>     notes={}
#>   }
  res_up_scatter:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf subgr\_temp\_average} subgr\_temp\_average
#>   \InputTable{
#>     name={subgr\_temp\_average},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={\texttt{plane}},
#>     valuesapplicable={\texttt{pin}},
#>     limitations={},
#>     description={This card is used to specify the fuel temperature averaging         %
#>                  scheme for the subgroup temperature correction.},
#>     notes={The averaged temperature is not directly used for cross section           %
#>            calculation. It is used to correct the non-uniform temperature            %
#>            effect in calculating the equivalence cross sections for subgroup method.}
#>   }
  subgr_temp_average:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() pin plane
#>
#>   {\bf dep\_filename} dep\_filename
#>   \VERAInputTable{
#>     name={dep\_filename},
#>    type={Free-Form Character String, Max. Length = 200},
#>    need={Required},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={No default value},
#>    valuesapplicable={filename of a supported cross section library},
#>    limitations={The format of this file should be consistent with the standard        %
#>      MPACT depletion library file \texttt{MPACT.dpl}.},
#>    description={This card is used to specify the depletion file to use, which         %
#>      provides all the data required in addition to the data in the transport          %
#>      library for depletion calculation.},
#>    notes={}
#>   }
  dep_filename:
    <<: *dtword
    _content:
    _check:
      - is_word()
#>
#>   {\bf mats\_file} mats\_file
#>   \VERAInputTable{
#>     name={mats\_file},
#>     type={Free-Form Character String, Max. Length = 200},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={No default value},
#>     valuesapplicable={filename of a HDF5 material database file},
#>     limitations={},
#>     description={This card is used to specify the name of the HDF5 material           %
#>       database file. This file is used to overwrite the isotopic and weight           %
#>       fraction values for default VERA material.},
#>     notes={Marked for deprecation, do not use!}
#>   }
  mats_file:
    <<: *dtword
    _content:
    _check:
      - is_word()
#>
#>   {\bf mod\_mat} mod\_mat
#>   \VERAInputTable{
#>     name={mod\_mat},
#>    type={Free-Form Character String, Max. Length = 200},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={\texttt{mod}},
#>    valuesapplicable={any user-defined name of the moderator material.},
#>    limitations={},
#>    description={This card is used to rename the moderator material.},
#>    notes={}
#>   }
  mod_mat:
    <<: *dtword
    _content:
    _check:
      - is_word()
#>
#>   {\bf subgroup\_set} subgroup\_set
#>   \VERAInputTable{
#>     name={subgroup\_set},
#>     type={Integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={4},
#>     valuesapplicable={integers 1 through 9},
#>     limitations={The \texttt{shield\_method} must be set to \texttt{subgroup}.        %
#>       ESSM ignores the \texttt{subgroup\_set} option.},
#>     description={This card is used to specify the subgroup set.},
#>     notes={In most cases, 4 (the default) should be used. This option finds a         %
#>       good balance on accuracy and computing time. In general, the                    %
#>       numbering is from 1 to 9, with 1 being the simplest                             %
#>       set (fast), and 9 being the most explicit set (slow).}
#>   }
  subgroup_set:
    <<: *dtword
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf cat\_onegroup} cat\_onegroup
#>   \VERAInputTable{
#>     name={cat\_onegroup},
#>     type={Array of Integers, Length = User Specified},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={3(if \texttt{subgroup\_set} = 4)},
#>     valuesapplicable={any integer number},
#>     limitations={The \texttt{shield\_method} must be set to \texttt{subgroup}.        %
#>       ESSM ignores the \texttt{cat\_onegroup} option.},
#>     description={This card is used to specify the categories that use one-group subgroup.},
#>     notes={The user can specify the categories that will use one-group subgroup       %
#>       treatment, which means a fast and approximate subgroup calculation in that      %
#>       category. If \texttt{subgroup\_set} = 4 (default), the default value of         %
#>       this option is 3 (clad category), otherwise no default category will be assigned to         %
#>       one-group subgroup unless user speficies. User can also specify zero or         %
#>       a negative integer number to use MG-subgroup for all categories.}
#>   }
  cat_onegroup:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_int(shift)},())
#>
#>   {\bf shld\_range} shld\_range
#>   \VERAInputTable{
#>     name={shld\_range},
#>     type={Array of Integers, Length = 2},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1,ng},
#>     valuesapplicable={between 1 and ng},
#>     limitations={Currently only simplified AMPX library supports this option},
#>     description={This card is used to specify the beginning and ending groups %
#>       that resonance self-shielding calculation will be performed.},
#>     notes={}
#>   }
  shld_range:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_int(shift)},())
#>
#>   {\bf k\_tol} k\_tol
#>   \VERAInputTable{
#>     name={k\_tol},
#>     type={Floating-Point Real Number},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1.0E-5},
#>     valuesapplicable={$>$0},
#>     limitations={},
#>     description={This card is used to specify the global tolerance on convergence     %
#>       of the eigenvalue.},
#>     notes={}
#>   }
  k_tolerance:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf flux\_tolerance} flux\_tolerance
#>   \VERAInputTable{
#>     name={flux\_tolerance},
#>     type={Floating-Point Real Number},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1.0E-4},
#>     valuesapplicable={$>$0},
#>     limitations={},
#>     description={This card is used to specify the tolerance on the convergence        %
#>       of the 2-norm of the flux.},
#>     notes={}
#>   }
  flux_tolerance:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf cmfd\_num\_outers} cmfd\_num\_outers
#>   \VERAInputTable{
#>     name={cmfd\_num\_outers},
#>    type={Integer},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={20},
#>    valuesapplicable={Any positive value.},
#>    limitations={},
#>    description={This card is used to specify the number of outer eigenvalue           %
#>      power iterations to perform during a CMFD acceleration calculation.},
#>   }
  num_outers:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() -1
#>
#>   {\bf cmfd\_num\_inners} cmfd\_num\_inners
#>   \VERAInputTable{
#>     name={cmfd\_num\_inners},
#>    type={Integer},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={100},
#>    valuesapplicable={Any positive integer.},
#>    limitations={},
#>    description={This card is used to specify the max. number of linear solver         %
#>      iterations per power iteration during a CMFD acceleration calculation.},
#>   }
  num_inners:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_geq() 0
#>
#>   {\bf cmfd\_up\_scatter} cmfd\_up\_scatter
#>   \VERAInputTable{
#>     name={cmfd\_up\_scatter},
#>    type={Integer},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={2},
#>    valuesapplicable={Any positive integer.},
#>    limitations={Only applies to \texttt{1gsweep} CMFD solver.},
#>    description={This card is used to specify the number of upscatter                  %
#>      iterations when doing \texttt{1gsweep} CMFD. This can help to converge the       %
#>      scattering source in thermal energy groups before updating the fission source.   %
#>      In general, this can be used to help optimize run time for a given problem.},
#>    notes={}
#>   }
  up_scatter:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_geq() 0
#>
#>   {\bf num\_extsrc\_itrs} num\_extsrc\_itrs
#>   \VERAInputTable{
#>     name={num\_extsrc\_itrs},
#>     type={Integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={num\_outers},
#>     valuesapplicable={$\ge$1},
#>     limitations={},
#>     description={This card is used to specify the number of outer iterations an       %
#>       external source strength iteration will perform before increasing the source    %
#>       strength.  If the current outer iteration value is equal to it, the source      %
#>       strengths will be increased by the strength multiplication factor, and outer    %
#>       iterations started again from count zero.  This will repeat until the source    %
#>       is at full strength, wherein the full num\_outers value will be used for the    %
#>       full strength iterations.},
#>     notes={}
#>   }
  num_extsrc_itrs:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf TL\_treatment} TL\_treatment
#>   \VERAInputTable{
#>     name={TL\_treatment},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={lflat},
#>     valuesapplicable={flat.  These are described as:                                  %
#>       \begin{itemize}                                                                 %
#>         \item \texttt{lflat} --- checks the total / transport cross section.          %
#>           If the value is below the threshold, leakage will not be put into           %
#>           that region.  This process is usually to avoid leakage in the fuel-         %
#>           clad gap.  It will then redistribute the leakage to the other               %
#>           regions in that pin.                                                        %
#>         \item \texttt{flat} --- does not perform leakage threshold checks.            %
#>       \end{itemize}},
#>     limitations={},
#>     description={This card is used to specify the type of spatial shape of the        %
#>       axial transverse leakage applied to the 2-D problem. Flat means it is constant  %
#>       over a pin cell. This is primarily used to ensure stability of the iteration.},
#>     notes={}
#>   }
  scattering:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() P0 P1 P2 P3 P4 P5 Pn0 TCP0 LTCP0 ITCP0
#>
#>   {\bf trim\_Pn\_moments} trim\_Pn\_moments
#>   \VERAInputTable{
#>    name={trim\_Pn\_moments},
#>    type={Boolean},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={true},
#>    valuesapplicable={true, false},
#>    limitations={},
#>    description={This card is used to toggle the logic to trim unused                 %
#>      scattering moments when using Pn scattering techniques.},                       %
#>    notes={}
#>   }
  trim_Pn_moments:
    <<: *dtbool
    _content:
    _check:
      - in_dictionary() true false
  boundary_update:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() none P0 DP0 P1
#>
#>   {\bf depl\_time\_method} depl\_time\_method
#>   \VERAInputTable{
#>     name={depl\_time\_method},
#>    type={Fixed Character String},
#>    need={Required},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={\texttt{p-c}(predictor-corrector)},
#>    valuesapplicable={\texttt{semip-c}(semi-predictor-corrector) or                    %
#>    \texttt{postcorrector}(semi-predictor-corrector-post-corrector)},
#>    limitations={},
#>    description={This card is used to specify the time stepping method in              %
#>      depletion. The \texttt{p-c} method computes a predicted nuclide                  %
#>      concentration based on the steady state flux condition at the beginning          %
#>      of time step, which is then averaged with the corrected nuclide                  %
#>      concentration based on the steady state flux condition at the end of             %
#>      time step. Two steady-state eigenvlaue calcualtions are performed for each       %
#>      depletion time step. The \texttt{p-c} method is a well demonstrated              %
#>      method and it can be used for large time steps. The \texttt{semip-c}             %
#>      method simplifies the \texttt{p-c} method by skipping the second steady-state    %
#>      eigenvalue calculation and thus becomes more efficient in small time             %
#>      step depletion calculation.  The \texttt{postcorrector} method is identical to   %
#>      \texttt{semip-c} method with the exception that the number                       %
#>      densities used for the beginning of times step steady-state eigenvalue           %
#>      calculation are "post-corrected" so that they more closely representthe          %
#>      averaged number densities of the full \texttt{p-c} method.  This allows for      %
#>      accuracy coparable to the full \texttt{p-c} method while still skipping the      %
#>      second steady-state eigenvalue calculation},
#>    notes={The \texttt{semip-c} method can result in an inconsistency when             %
#>      restarting.  However, the differences that arise from a \texttt{semip-c} restart %
#>      are smaller in magnitude than the differences between \texttt{semip-c} and       %
#>      \texttt{p-c}. The inconsistency in the \texttt{semip-c} restart arises from an   %
#>      extra flux calculation that occurs on restart, so presumably the difference      %
#>      results in a more accurate solution.}
#>   }
  depl_time_method:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() p-c semip-c postcorrector
#>
#>   {\bf depl\_origen\_solver} depl\_origen\_solver
#>   \VERAInputTable{
#>     name={depl\_origen\_solver},
#>    type={Fixed Character String},
#>    need={Required},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={\texttt{cram}(CRAM solver)},
#>    valuesapplicable={\texttt{matrex}(MATREX solver)},
#>    limitations={},
#>    description={This card is used to specify the solver method used by ORIGEN         %
#>      when performing depletion calculations.  The \texttt{cram} method is the         %
#>      Chebyshev Rational Approximation Method.  The \texttt{matrex} method is a hybrid %
#>      matrix exponential / linear chain method, and is the legacy ORIGEN solution      %
#>      method},
#>    notes={Compared to the \texttt{matrex} solver, \texttt{cram} has similar runtimes  %
#>      but is more accurate and robust on a larger range of problems.  Unlike           %
#>      \texttt{matrex}, the length of a step does not significantly affect the accuracy %
#>      of \texttt{cram}, in the absence of substep power renormalization. Hence, it is  %
#>      recommended that \texttt{cram} be used for ORIGEN depletion solves}
#>   }
  depl_origen_solver:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() matrex cram
#>
#>   {\bf num\_space} num\_space
#>   \VERAInputTable{
#>     name={num\_space},
#>    type={Integer},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={1},
#>    valuesapplicable={Integer greater than 0 and less than the number of CPU cores.},
#>    limitations={},
#>    description={This card is used to specify the number of spatial                    %
#>      decomposition regions used in a parallel execution step.                         %
#>      this value can be:                                                               %
#>      \begin{enumerate}                                                                %
#>        \item a subset of the number of planes in the model,                           %
#>        \item the total number of planes, or                                           %
#>        \item a product of all of the planes and any number of radial regions          %
#>              comprised of groups of quarter assemblies.                               %
#>      \end{enumerate}                                                                  %
#>      The ability to decompose a problem by planes can be                              %
#>      used with the \texttt{DEFAULT} partition method. Any partition that              %
#>      decomposes the problem radially requires the \texttt{EXPLICITFILE}               %
#>      partition method.},
#>    notes={See description of card \texttt{num\_angle} for explanation of              %
#>      using spatial and angular decomposition in conjunction.}
#>   }
  num_space:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf num\_angle} num\_angle
#>   \VERAInputTable{
#>    name={num\_angle},
#>    type={Integer},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={1},
#>    valuesapplicable={Integer greater than 0 and less than the number of CPU cores.},
#>    limitations={Specifying a value greater than 2*\texttt{azimuthals\_octant}         %
#>      will cause an exception error.},
#>    description={This input options specifies the number of parallel                   %
#>      partitions used to decompose the problem based on the azimuthal angle (i.e.      %
#>      ray directions in the x-y plane). To get the 2D MOC solution for a single        %
#>      x-y plane, rays are traced through the domain in multiple azimuthal              %
#>      directions, as specified by the user in the option                               %
#>      \texttt{azimuthals\_octant} (the user should note that the terms octant          %
#>      and quadrant are interchangable in the context of azimuthal angles).             %
#>      \newline                                                                         %
#>      The azimuthal angles are divided                                                 %
#>      into \texttt{num\_angle} groups, and each groups is assigned to a                %
#>      parallel partition (i.e. process). If spatial                                    %
#>      decomposition is used in the same problem, then each spatial                     %
#>      decomposition region is copied to \texttt{num\_angle} partitions.                %
#>      Therefore, the total number of parallel partitions is                            %
#>      \texttt{num\_angle}*\texttt{num\_space}.},
#>    notes={The user is cautioned against using too many processes to decompose         %
#>      the problem. Due to the increase in inter-process communication with             %
#>      increased parallel decomposition, excessive parallelization will not yield       %
#>      speedup of the solution. The proper amount of paralleization will have to        %
#>      be determined on a case-by-case basis.}
#>   }
  num_angle:
    <<: *dtint
    _content:
    _check:
      - is_int()
  num_energy:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_eq() 1
#>
#>   {\bf num\_threads} num\_threads
#>   \VERAInputTable{
#>     name={num\_threads},
#>    type={Integer},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={1},
#>    valuesapplicable={Integer greater than 0 and less than the number of CPU cores.},
#>    limitations={},
#>    description={This card is used to specify the number of threads used in            %
#>      parallel execution. The number of threads specified are used only                %
#>      during the MOC transport sweep. For a given ray direction (i.e. angle),          %
#>      threads are used to sweep multiple rays in parallel.},
#>    notes={It is recommended that                                                      %
#>      \texttt{num\_angle}*\texttt{num\_space}*\texttt{num\_threads} does not           %
#>      exceed the total number of physical CPU cores. MPACT will still run              %
#>      if the user exceeds this limit, but the parallel performance will be             %
#>      degraded.}
#>   }
  num_threads:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf par\_method} par\_method
#>   \VERAInputTable{
#>    name={par\_method},
#>    type={Fixed Character String},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={\texttt{DEFAULT}},
#>    valuesapplicable={\texttt{EXPLICITFILE}},
#>    limitations={The \texttt{EXPLICITFILE} option may be used only if the user         %
#>      has created a partition file. For a description of the partition file, see       %
#>      the input option \texttt{par\_file}.},
#>    description={This card is used to specify the method of parallel decomposition.    %
#>      \begin{itemize}                                                                  %
#>        \item \texttt{DEFAULT} --- The parallelization is specified by three           %
#>          input options listed below: \texttt{num\_angle}, \texttt{num\_space},        %
#>          \texttt{num\_threads}. The meanings of these input options are explained     %
#>          below. \texttt{DEFAULT} is the simpler method for parallelizing the problem, %
#>          and is recommended for most users.                                           %
#>        \item \texttt{ASSEMBLY} --- The parallelization scheme for decomposing         %
#>          a problem spatially.  The problem will be decomposed radially first,         %
#>          and if there are more processors, will then attempt to parallelize           %
#>          the problem axially.  This process is done automatically, and only           %
#>          requires the user to specify the number of spatial processors available      %
#>          in the \texttt{num\_space} card described below.  It is the recommended      %
#>          method for large problems.                                                   %
#>        \item \texttt{EXPLICITFILE} --- For more advanced users who are running        %
#>          large problems, using the \texttt{EXPLICITFILE} option may enable the user   %
#>          to parallelize the problem more effectively. For a description of the        %
#>          \texttt{EXPLICITFILE} method, see the input option \texttt{par\_file}.
#>      \end{itemize}},
#>    notes={}
#>   }
  par_method:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() explicitradial EXPLICITRADIAL explicitfile EXPLICITFILE assembly ASSEMBLY ps PS graph GRAPH
#>
#>   {\bf par\_file} par\_file
#>   \VERAInputTable{
#>     name={par\_file},
#>    type={Free-Form Character String},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={\texttt{partition.txt}},
#>    valuesapplicable={},
#>    limitations={No comments are allowed in the file.},
#>    description={This card is used to specify the parallel decomposition file          %
#>      if \texttt{EXPLICITFILE} is used. This is an advanced feature that is            %
#>      not recommended for most users. The MPACT domain is broken into a regular        %
#>      grid of ray trace modules; the partition file allows the user to specify         %
#>      the spatial decomposition of the domain by listing the ray trace modules in      %
#>      each spatial partition via their (x,y,z)                                         %
#>      indices (this is explained more in the following paragraphs). The                %
#>      partition file also allows the user to decompose the MPACT domain radially,      %
#>      which is not possible                                                            %
#>      with the \texttt{DEFAULT} partition method. \newline                             %
#>      The file structure itself has two header lines followed by the                   %
#>      specification of the radial partition regions.\newline                           %
#>      The first line has 3 values, the first is the number of MPACT ray trace          %
#>      modules in the x direction, the second is the number of ray trace modules        %
#>      in the y direction, and the third is the number of axial planes in the           %
#>      model.\newline                                                                   %
#>      The second line also has 3 values. The first two pertain specifically to how     %
#>      MPACT partitions ray trace modules in space, and these values should always      %
#>      be 0 and 1 respectively.  The third value should be the number of radial         %
#>      partitions being subsequently specified.\newline                                 %
#>      The following lines should describe all radial partition regions for the         %
#>      problem including any regions that will be used with a jagged core. The input    %
#>      for each line is 6 integers.  The first pair of integers are the starting and    %
#>      stopping module indices in the x direction, the second pair are the starting     %
#>      and stopping module indices in the y direction, and the last pair is for the     %
#>      z direction, but they are ignored currently and all radial partitions are        %
#>      assumed to be the same for each axial plane.  The coordinate system point of     %
#>      origin when specifying the starting and stopping indices is the lower left       %
#>      (south-west) corner of the module. When specifying the starting and stopping     %
#>      indices, it is important to note that these are not necessarily the assembly     %
#>      positions.  Typically, in the case of modeling a full reactor, the ray trace     %
#>      modules represent a quarter of an assembly. In this case,                        %
#>      the number of ray trace modules in a given direction will be about twice the     %
#>      number of assemblies in that direction.},
#>    notes={If the core is jagged, additional attention is required to keep             %
#>      track of the actual number of processors being used by MPACT.                    %
#>      Even though the non-existent assemblies are "partitioned" in the                 %
#>      explicit file, nothing there will be run. So the user cannot simply              %
#>      take the third value from the second line and multiply it by the third           %
#>      value from the first line to get the total number of spatial partitions          %
#>      for this case.  In the example below, the third value in the second              %
#>      line must have the number of "jagged" partitions subtracted from it.             %
#>      In this case, the actual number of processors per plane becomes                  %
#>      49 - 8 = 41. That number can then be multiplied by the number of                 %
#>      planes to get 2378 processors, which should be input into the                    %
#>      \texttt{num\_space} card.\newline                                                %
#>      Also, it may be unclear to the user how many planes will be created              %
#>      in MPACT before the case is run. The output file has a summary of                %
#>      the axial mesh information, including the total number of planes.                %
#>      If the case crashes when using the partition file, check that the                %
#>      number of planes specified matches the value in the output file.},
#>   }
  par_file:
    <<: *dtword
    _content:
    _check:
      - is_word()
  par_xdim:
    <<: *dtword
    _content:
    _check:
      - is_int()
  par_ydim:
    <<: *dtword
    _content:
    _check:
      - is_int()
  par_map:
    <<: *dtlist
    _style: multi-line
    _check:
      - fall(sub{is_int(shift)},())
  graph_part_method:
    <<: *dtlist
    _content:
    _check:
      - fall(sub{is_word(shift)},())
      - fall(sub{in_dictionary(shift,'RSB','RIB','REB')},())
  graph_refn_method:
    <<: *dtlist
    _content:
    _check:
      - fall(sub{is_word(shift)},())
      - fall(sub{in_dictionary(shift,'none','NONE','KL','SKL')},())
  graph_cond:
    <<: *dtlist
    _content:
    _check:
      - fall(sub{is_int(shift)},())
      - fall(sub{is_gt(shift,0)},())
#>
#>   {\bf coupling\_method} coupling\_method
#>   \VERAInputTable{
#>     name={coupling\_method},
#>    type={Fixed Character String},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={\texttt{simplified} (if not configured with COBRA-TF)                %
#>      \emph{or} \texttt{ctf} (if configured with COBRA-TF)},
#>    valuesapplicable={\texttt{ctf\_external}, \texttt{none}                            %
#>      \newline\newline                                                                 %
#>      The \texttt{simplified} option uses MPACT's internal TH solver.  The             %
#>      \texttt{ctf} option internally couples COBRA-TF to MPACT, and                    %
#>      \texttt{ctf\_external} couples MPACT and COBRA-TF through the lime               %
#>      interface. The \texttt{none} option will use parameters from the                 %
#>      \texttt{STATE} block: fuel temperatures will be constant and equal to            %
#>      \texttt{tfuel}, moderator temperatures will be constant and equal to             %
#>      \texttt{tinlet}, and moderator densities will be constant and equal to           %
#>      \texttt{modden}. },
#>    limitations={The \texttt{feedback} card in the \texttt{STATE} block                %
#>      must be set to \texttt{on} for any of the three TH coupling methods},
#>    description={This card is used to indicate which TH coupling method                %
#>      should be used.},
#>    notes={For either the \texttt{ctf} or \texttt{ctf\_external} options,              %
#>      MPACT must be configured with COBRA-TF.  The \texttt{internal} option            %
#>      may regardless of whether MPACT was configured with COBRA-TF or not.}
#>   }
  coupling_method:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() ctf simplified ctf_external tiamat none
#>
#>   {\bf th\_nonlinear\_solver} th\_nonlinear\_solver
#>   \VERAInputTable{
#>     name={th\_nonlinear\_solver},
#>    type={Fixed Character String},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={\texttt{picard}},
#>    valuesapplicable={\texttt{picard}, \texttt{anderson}                               %
#>      \newline\newline                                                                 %
#>      The \texttt{picard} option uses a direct underrelaxation of the power.           %
#>      The \texttt{anderson} option uses the Anderson acceleration method in            %
#>      Trilinos to accelerate on the power. },
#>    limitations={For \texttt{anderson} the \texttt{anderson\_options} card should      %
#>      be used to set parameters.},
#>    description={This card is used to indicate which nonlinear solver should be        %
#>      used for the coupling.},
#>    notes={For the \texttt{anderson} option, MPACT must be configured with Trilinos.   %
#>      The \texttt{picard} option may regardless of how MPACT is configured.}
#>   }
  th_nonlinear_solver:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() picard anderson
#>
#>   {\bf anderson\_options} anderson\_options
#>   \VERAInputTable{
#>     name={anderson\_options},
#>    type={Integer, Floating-Point Real Number, Integer},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={2, 0.5, 1},
#>    valuesapplicable={                                                                 %
#>      The \texttt{depth} can be any non-negative integer which represents              %
#>      depth of the Anderson solver.                                                    %
#>      The \texttt{mixing parameter} must be greater than 0 and less than or            %
#>      equal to 1.                                                                      %
#>      The \texttt{starting iteration} must be a positive integer which represents      %
#>      how many iterations of picard to perform before starting anderson.},
#>    limitations={},
#>    description={This card is used to define the solver parameters for the             %
#>      Anderson nonlinear solver.},
#>   }
  anderson_options:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==3
      - is_int(nth(0,()))
      - is_float(nth(1,()))
      - is_int(nth(2,()))
      - nth(0,())>=0
      - nth(1,())>0
      - nth(2,())>0
#>
#>   {\bf shielder\_th} shielder\_th
#>   \VERAInputTable{
#>     name={shielder\_th},
#>    type={Integer, Floating-Point Real Number, Floating-Point Real Number},
#>    need={Optional},
#>    unitsdefault={\{unitless, K, g/cm$^3$\}},
#>    unitsother={},
#>    valuedefault={4, 25.0, 0.005},
#>    valuesapplicable={or any positive integer and any 2 positive real numbers          %
#>      \newline\newline                                                                 %
#>      The first input is the maximum number of outer                                   %
#>      iterations for which MPACT will perform cross-section shielding                  %
#>      calculations following a TH update. The second input is the minimum              %
#>      change in temperature for which MPACT will perform cross-section                 %
#>      shielding calculations following a TH update. The third and last input           %
#>      is the minimum change in moderator density for which MPACT will                  %
#>      perform cross-section shielding calculations following a TH update.},
#>    limitations={If the \texttt{xs{\_}shielder} card is set to \texttt{f} or           %
#>      \texttt{false}, this card does nothing, since cross-section shielding            %
#>      calculations will never be performed.},
#>    description={This card is used to control how many cross-section shielding         %
#>      calculations are performed when using TH feedback.  It sets a maximum            %
#>      number of iterations with shielding calculations, and also sets                  %
#>      parameters to stop the shielding calculations earlier if the TH                  %
#>      feedback effects on temperature and moderator density are small enough.},
#>    notes={If multiple state points are performed in the calculation, the              %
#>      counter for the <shield\_max\_outers> input is reset for each state point.       %
#>      \newline                                                                         %
#>      If the \texttt{xs{\_}shielder} card is not set to \texttt{f} or \texttt{false},  %
#>      shielding calculations will always be performed on the first iteration.}
#>   }
  shielder_th:
    <<: *dtlist
    _content:
    _check:
      - arraysize()==3
      - is_int(nth(0,()))
      - is_float(nth(1,()))
      - is_float(nth(2,()))
      - nth(0,())>0
      - nth(1,())>0
      - nth(2,())>0
#>
#>   {\bf outers\_per\_TH} outers\_per\_TH
#>   \VERAInputTable{
#>     name={outers\_per\_TH},
#>    type={Integer},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={1},
#>    valuesapplicable={or any positive integer},
#>    limitations={},
#>    description={This card is used to indicate how many outer iterations               %
#>      MPACT should perform before performing an additional TH update.},                %
#>    notes={}
#>   }
  outers_per_TH:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf average\_ftemp} average\_ftemp
#>   \VERAInputTable{
#>     name={average\_ftemp},
#>    type={Fixed Character String},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={\texttt{true}},
#>    valuesapplicable={\texttt{false}},
#>    limitations={},
#>    description={If true, this card applies a volume-avergaed fuel temperature         %
#>      to each fuel pin.  If false, it applies a radially dependent fuel                %
#>      temperature to each fuel pin.},
#>    notes={}
#>   }
  average_ftemp:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf ctf\_basename} ctf\_basename
#>   \VERAInputTable{
#>     name={ctf\_basename},
#>    type={Free-Form Character String, Max. Length = 200},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={\texttt{deck} (when COBRA-TF is run in serial) \emph{or}             %
#>      \texttt{pdeck} (when COBRA-TF is run in parallel)},
#>    valuesapplicable={Any filename base for valid COBRA-TF input decks.},
#>    limitations={Filename must have ".inp" extension.},
#>    description={This card is used to indicate the "basename" of the CTF               %
#>      input files for CTF coupling. The "basename" is the section of the CTF           %
#>      input filename(s) without any extensions.},
#>    notes={Absolute or relative paths to the file are both acceptable.}
#>   }
  ctf_basename:
    <<: *dtword
    _content:
    _check:
      - is_word()
#>
#>   {\bf sth\_dhfrac} sth\_dhfrac
#>   \VERAInputTable{
#>     name={sth\_dhfrac},
#>    type={Floating-Point Real Number},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={0.02},
#>    valuesapplicable={0.0--1.0},
#>    limitations={It is ignored if feedback is off or if coupling with                  %
#>      COBRA-TF is being used.},
#>    description={This card is used to set the fraction of the power which is           %
#>      directly deposited in the moderator in internal TH calculations.},
#>    notes={}
#>   }
  sth_dhfrac:
    <<: *dtfloat
    _content:
    _check:
      - is_float()
      - is_geq() 0
#>
#>   {\bf sth{\_} sth{\_
#>   \VERAInputTable{
#>     name={sth{\_}hgap},
#>    type={Floating-Point Real Number},
#>    need={Optional},
#>    unitsdefault={W/m$^2 \cdot$ K},
#>    unitsother={},
#>    valuedefault={4500.0},
#>    valuesapplicable={or any positive real number},
#>    limitations={It is ignored if feedback is off or if coupling with                  %
#>      COBRA-TF is being used.},
#>    description={This card is used to set the gap conductance value for                %
#>      internal TH calculations.},
#>    notes={Typical values range from 1000 (very low) to 10000 (very high).}
#>   }
  sth_hgap:
    <<: *dtfloat
    _content:
    _check:
      - is_float()
      - is_geq() 0
#>
#>   {\bf temptable\_filename} temptable\_filename
#>   \VERAInputTable{
#>     name={temptable\_filename},
#>    type={Free-Form Character String, Max. Length = 200},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={N/A},
#>    valuesapplicable={Filename of any valid fuel temperature table file},
#>    limitations={If the card is present, temperature tables in the named file          %
#>      will be used to calculate fuel temperatures instead of the internal              %
#>      conduction solvers or COBRA-TF. If this card is not present, then                %
#>      internal or COBRA-TF solvers are used.},
#>    description={This card is used to indicate the name of the file                    %
#>      containing the temperature tables.},
#>    notes={Temperature tables contain fuel temperature values as functions of          %
#>      power and burnup.  When depleting, the thermal properties of the fuel            %
#>      change significantly.  Internal TH and COBRA-TF do not know how these            %
#>      properties change when depleting, so temperature tables can be used to           %
#>      more accurately perform TH calculations during depletion simulations             %
#>      using tabulated data rather than fuel conduction solvers.}
#>   }
  sth_channeltype:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() assem node chan
  sth_tabletype:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() ctf simplified
#>
#>   {\bf temptable\_filename} temptable\_filename
#>   \VERAInputTable{
#>     name={temptable\_filename},
#>    type={Free-Form Character String, Max. Length = 200},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={N/A},
#>    valuesapplicable={Filename of any valid fuel temperature table file},
#>    limitations={If the card is present, temperature tables in the named file          %
#>      will be used to calculate fuel temperatures instead of the internal              %
#>      conduction solvers or COBRA-TF. If this card is not present, then                %
#>      internal or COBRA-TF solvers are used.},
#>    description={This card is used to indicate the name of the file                    %
#>      containing the temperature tables.},
#>    notes={Temperature tables contain fuel temperature values as functions of          %
#>      power and burnup.  When depleting, the thermal properties of the fuel            %
#>      change significantly.  Internal TH and COBRA-TF do not know how these            %
#>      properties change when depleting, so temperature tables can be used to           %
#>      more accurately perform TH calculations during depletion simulations             %
#>      using tabulated data rather than fuel conduction solvers.}
#>   }
  sth_avgpin:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
  temptable_shape:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf temptable\_boundary} temptable\_boundary
#>   \VERAInputTable{
#>     name={temptable\_boundary},
#>    type={Fixed Character String},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={N/A},
#>    valuesapplicable={Boundary for applying the temperature tables},
#>    limitations={If the card is present, temperature tables in the named file          %
#>      will be used to calculate fuel temperatures instead of the internal              %
#>      conduction solvers or COBRA-TF. If this card is not present, then                %
#>      internal or COBRA-TF solvers are used.},
#>    description={This card is used to define boundary from which the table was         %
#>      generated and which should be used to apply the table.},
#>    notes={Temperature tables contain fuel temperature values as functions of          %
#>      power and burnup.  When depleting, the thermal properties of the fuel            %
#>      change significantly.  Internal TH and COBRA-TF do not know how these            %
#>      properties change when depleting, so temperature tables can be used to           %
#>      more accurately perform TH calculations during depletion simulations             %
#>      using tabulated data rather than fuel conduction solvers.}
#>   }
  temptable_boundary:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() clad_outer bulk_cool
#>
#>   {\bf temptable\_filename} temptable\_filename
#>   \VERAInputTable{
#>     name={temptable\_filename},
#>    type={Free-Form Character String, Max. Length = 200},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={N/A},
#>    valuesapplicable={Filename of any valid fuel temperature table file},
#>    limitations={If the card is present, temperature tables in the named file          %
#>      will be used to calculate fuel temperatures instead of the internal              %
#>      conduction solvers or COBRA-TF. If this card is not present, then                %
#>      internal or COBRA-TF solvers are used.},
#>    description={This card is used to indicate the name of the file                    %
#>      containing the temperature tables.},
#>    notes={Temperature tables contain fuel temperature values as functions of          %
#>      power and burnup.  When depleting, the thermal properties of the fuel            %
#>      change significantly.  Internal TH and COBRA-TF do not know how these            %
#>      properties change when depleting, so temperature tables can be used to           %
#>      more accurately perform TH calculations during depletion simulations             %
#>      using tabulated data rather than fuel conduction solvers.}
#>   }
  temptable_filename:
    <<: *dtword
    _content:
    _check:
      - is_word()
#>
#>   {\bf temptable\_qprime} temptable\_qprime
#>   \VERAInputTable{
#>     name={temptable\_qprime},
#>    type={Floating-Point Real Numbers},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={N/A},
#>    valuesapplicable={Heat flux used to generate the fuel temperatures},
#>    limitations={If the card is present, temperature tables in the named file          %
#>      will be used to calculate fuel temperatures instead of the internal              %
#>      conduction solvers or COBRA-TF. If this card is not present, then                %
#>      internal or COBRA-TF solvers are used.},
#>    description={This card is used to define the heat flux used to generate fuel       %
#>      temperature tables.},
#>    notes={Temperature tables contain fuel temperature values as functions of          %
#>      power and burnup.  When depleting, the thermal properties of the fuel            %
#>      change significantly.  Internal TH and COBRA-TF do not know how these            %
#>      properties change when depleting, so temperature tables can be used to           %
#>      more accurately perform TH calculations during depletion simulations             %
#>      using tabulated data rather than fuel conduction solvers.}
#>   }
  temptable_qprime:
    <<: *dtfloat
    _content:
    _check:
      - is_float()
      - is_geq() 0
#>
#>   {\bf temptable\_polynomial} temptable\_polynomial
#>   \VERAInputTable{
#>     name={temptable\_polynomial},
#>    type={Floating-Point Real Numbers},
#>    need={Optional},
#>    unitsdefault={GWD/MT, K, K},
#>    unitsother={},
#>    valuedefault={N/A},
#>    valuesapplicable={Fuel temperature table values},
#>    limitations={If the card is present, temperature tables                            %
#>      will be used to calculate fuel temperatures instead of the internal              %
#>      conduction solvers or COBRA-TF. If this card is not present, then                %
#>      internal or COBRA-TF solvers are used.},
#>    description={This card is used to indicate the data for temperature tables.},
#>    notes={Temperature tables contain fuel temperature values as functions of          %
#>      power and burnup.  When depleting, the thermal properties of the fuel            %
#>      change significantly.  Internal TH and COBRA-TF do not know how these            %
#>      properties change when depleting, so temperature tables can be used to           %
#>      more accurately perform TH calculations during depletion simulations             %
#>      using tabulated data rather than fuel conduction solvers.}
#>   }
  temptable_polynomial:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - arraysize()%3==0
      - fall(sub{is_float(shift)},stride(0,3,()))
      - fall(sub{is_float(shift)},stride(1,3,()))
      - fall(sub{is_float(shift)},stride(2,3,()))
      - fall(sub{is_geq(shift,0)},stride(0,3,()))
#>
#>   {\bf dep\_edit} dep\_edit
#>   \VERAInputTable{
#>     name={dep\_edit},
#>    type={Fixed Character String},
#>    need={Optional},
#>    unitsdefault={atoms\/volume of pincell},
#>    unitsother={},
#>    valuedefault={\texttt{true}},
#>    valuesapplicable={\texttt{false}},
#>    limitations={},
#>    description={This card is used to specify if the depletion \texttt{Isum}           %
#>      and \texttt{Pnum} files are written, which print the pin-wise averaged           %
#>      isotope number densities. \texttt{Isum} prints the isotope summary file          %
#>      with isotopes tracked in XSMesh and \texttt{Pnum} file prints the particle       %
#>      number density file with all isotopes in the depletion library.},
#>    notes={The option has excessive memory requirements and is not advised for
#>      general usage. Only use when absolutely necessary.}
#>   }
  dep_edit:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf dep\_substep} dep\_substep
#>   \VERAInputTable{
#>     name={dep\_substep},
#>    type={Integer},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={1},
#>    valuesapplicable={Positive integers greater than 0},
#>    limitations={},
#>     description={This card is used to read the number of substep for the              %
#>       Depletion Predictor AND Corrector step. The substep method is applied to        %
#>       perform multiple depletion calculations between transport calculations.         %
#>       Substeps should be set to 1 if using CRAM and no High Order Depletion or        %
#>       substep renormalization.  Since the depletion calculation typically takes       %
#>       less time than the transport calculation this with high order depletion or      %
#>       renormalization will often save computational time. },
#>     notes={When not using the High Order Depletion Methodology or substep             %
#>      renormalization, 1 substep is recommended for CRAM and 3 substeps for MATREX or  %
#>      internal BATEMAN.  This card is also valid in OPTION block.}
#>   }
  dep_substep:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf dep\_substep\_pred} dep\_substep\_pred
#>   \VERAInputTable{
#>     name={dep\_substep\_pred},
#>    type={Integer},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={1},
#>    valuesapplicable={Positive integers greater than 0},
#>    limitations={},
#>     description={This card is used to read the number of substep for the              %
#>       Depletion Predictor step. The substep method is applied to                      %
#>       perform multiple depletion calculations between transport calculations.         %
#>       Substeps should be set to 1 if using CRAM and no High Order Depletion or        %
#>       substep renormalization.  Since the depletion calculation typically takes       %
#>       less time than the transport calculation this with high order depletion or      %
#>       renormalization will often save computational time. },
#>     notes={When not using the High Order Depletion Methodology or substep             %
#>      renormalization, 1 substep is recommended for CRAM and 3 substeps for MATREX or  %
#>      internal BATEMAN.  This card is also valid in OPTION block.}
#>   }
  dep_substep_pred:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf dep\_substep\_corr} dep\_substep\_corr
#>   \VERAInputTable{
#>     name={dep\_substep\_corr},
#>    type={Integer},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={1},
#>    valuesapplicable={Positive integers greater than 0},
#>    limitations={},
#>     description={This card is used to read the number of substep for the              %
#>       Depletion Corrector step. The substep method is applied to                      %
#>       perform multiple depletion calculations between transport calculations.         %
#>       Substeps should be set to 1 if using CRAM and no High Order Depletion or        %
#>       substep renormalization.  Since the depletion calculation typically takes       %
#>       less time than the transport calculation this with high order depletion or      %
#>       renormalization will often save computational time. },
#>     notes={When not using the High Order Depletion Methodology or substep             %
#>      renormalization, 1 substep is recommended for CRAM and 3 substeps for MATREX or  %
#>      internal BATEMAN.  This card is also valid in OPTION block.}
#>   }
  dep_substep_corr:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf dep\_kernel} dep\_kernel
#>   \VERAInputTable{
#>     name={dep\_kernel},
#>    type={Fixed Character String},
#>    need={Required},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={\texttt{internal}(MPACT's internal depletion kernel)},
#>    valuesapplicable={\texttt{origen}(coupled \texttt{origen} kernel)},
#>    limitations={},
#>    description={This card is used to specify the depletion kernel to use.             %
#>      The MPACT internal depletion kernel is based on the same methodology             %
#>      as \texttt{origen}, but uses simplified depletion chains and runs faster         %
#>      than \texttt{origen}.},
#>    notes={}
#>   }
  dep_kernel:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() internal origen
  include_depl_mats:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_word(shift)},())
  exclude_depl_mats:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_word(shift)},())
#>
#>   {\bf cmfd} cmfd
#>   \VERAInputTable{
#>     name={cmfd},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={cmfd},
#>     valuesapplicable={cmfd, none described as:                                        %
#>       \begin{itemize}                                                                 %
#>         \item \texttt{cmfd} --- default CMFD method (currently adcmfd.)               %
#>         \item \texttt{adcmfd} --- artificially diffusive CMFD method. (same as cmfd)  %
#>         \item \texttt{scmfd} --- standard CMFD method.                                %
#>         \item \texttt{mlcmfd} --- a multi-level (currently 2) cmfd method.            %
#>         \item \texttt{msed} --- same as \texttt{adcmfd}, but the CMFD                 %
#>           system is now solved via the MSED method                                    %
#>         \item \texttt{none} --- disables CMFD and can only be used in 2-D             %
#>           problems.                                                                   %
#>       \end{itemize}},
#>     limitations={},
#>     description={This card is used to specify which CMFD method will be used.},
#>     notes={CMFD must be present for every 3-D problem because it is the basis         %
#>       for the solution transfer between 2-D and 1-D.}
#>   }
  cmfd:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() cmfd ycmfd adcmfd scmfd mlcmfd msed none

#>
#>   {\bf multilevel} multilevel
#>   \VERAInputTable{
#>     name={multilevel},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={energy},
#>     valuesapplicable={energy,space},
#>     limitations={},
#>     description={This card is used to specify whether space or energy multilevel CMFD is used},
#>     notes={Only active when mlcmfd is specified.}
#>   }
#
  multilevel:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() energy space

  prolongation:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() linear flat
#>
#>   {\bf cmfd\_solver} cmfd\_solver
#>   \VERAInputTable{
#>     name={cmfd\_solver},
#>    type={Fixed Character String},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={\texttt{mgnode}},
#>    valuesapplicable={\texttt{mgnode}, \texttt{mggroup} described as:                  %
#>      \begin{itemize}                                                                  %
#>        \item \texttt{1gsweep} --- sweeps through all of the energy groups             %
#>          one by one using Gauss-Seidel iteration in energy.                           %
#>        \item \texttt{mgnode} --- sets up a full multigroup CMFD matrix in             %
#>          node-major ordering (e.g. each node is a group-by-group block).              %
#>        \item \texttt{mggroup} --- sets up a full multigroup CMFD matrix in            %
#>          group-major ordering.                                                        %
#>        \item \texttt{1grbsor} --- sweeps through all of the energy groups             %
#>          one by one using Red-Black Successive Over-Relaxtion iteration.              %
#>        \item \texttt{mgrbsor} --- sets up a full multigroup CMFD matrix in            %
#>          node-major ordering (e.g. each node is a group-by-group block) and           %
#>          uses Red-Black Successive Over-Relaxtion iteration.                          %
#>        \item \texttt{reducedmg} -- same as mgnode, except it solve the                %
#>          groups without an upscattering source one group at a time before             %
#>          forming a multigroup matrix with only the upscattering groups.               %
#>          DOES NOT WORK WITH WIELANDT SHIFT.  k\_shift (or lambda\_shift) must         %
#>          be 0.
#>      \end{itemize}},
#>    limitations={},
#>    description={This card is used to specify how the CMFD linear system is            %
#>      setup and solved.},
#>    notes={\texttt{1gsweep} requires less memory than the others, but is generally     %
#>      slower to converge than mgnode.}
#>   }
  cmfd_solver:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() 1gsweep mgnode mggroup mgrbsor reducedmg
#>
#>   {\bf cmfd\_linear\_solver} cmfd\_linear\_solver
#>   \VERAInputTable{
#>     name={cmfd\_linear\_solver},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={PETSC},
#>     valuesapplicable={PETSC or TRILINOS described as:                      %
#>       \begin{itemize}                                                                 %
#>         \item \texttt{PETSC} --- Uses PETSC (ANL) for linear solver and SLEPC for eigenvalue problems.                       %
#>         \item \texttt{TRILINOS} --- Uses Trilinos (SNL) solvers Belos for linear solves and Anasazi for eigenvalue problems. %
#>       \end{itemize}},
#>     limitations={},
#>     description={This card is used to specify which linear solver package will be used.},
#>     notes={CMFD must be present for every 3-D problem because it is the basis         %
#>       for the solution transfer between 2-D and 1-D.}
#>   }
  cmfd_linear_solver:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() petsc trilinos
#>
#>   {\bf petsc\_linear\_solver\_method} petsc\_linear\_solver\_method
#>   \VERAInputTable{
#>     name={petsc\_linear\_solver\_method},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={gmres},
#>     valuesapplicable={gmres, bicgstab, or multigrid},
#>     limitations={},
#>     description={This card is used to specify which linear solver from PETSc will     %
#>       be used.  It does nothing if Trilinos is chosen as the linear solver.}
#>   }
  petsc_linear_solver_method:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() gmres bicgstab multigrid
#>
#>   {\bf petsc\_linear\_solver\_method} petsc\_linear\_solver\_method
#>   \VERAInputTable{
#>     name={petsc\_linear\_solver\_method},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={gmres},
#>     valuesapplicable={gmres, bicgstab, or multigrid},
#>     limitations={},
#>     description={This card is used to specify which linear solver from PETSc will     %
#>       be used.  It does nothing if Trilinos is chosen as the linear solver.}
#>   }
  petsc_linear_solver_method_1G:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() gmres bicgstab multigrid
#>
#>   {\bf multigrid\_cg\_solver} multigrid\_cg\_solver
#>   \VERAInputTable{
#>     name={multigrid\_cg\_solver},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={gmres},
#>     valuesapplicable={sor, bjacobi, gmres, bicgstab, or lu},
#>     limitations={},
#>     description={                                                                     %
#>       This card is used to control the solver used on the coarsest grid of            %
#>       multigrid. The options are: \begin{itemize}                                     %
#>       \item \texttt{gmres} -- Standard GMRES solver in PETSc, with a                  %
#>          preconditioner that is ILU-like locally and Jacobi-like between              %
#>          processors.                                                                  %
#>       \item \texttt{bicgstab} -- Standard BiCGSTAB solver in PETSc, same              %
#>          preconditioner as GMRES.                                                     %
#>       \item \texttt{lu} -- Exact LU solver.  In parallel, superLU package             %
#>          must be enabled to use this.                                                 %
#>       \item Any of the options for the \texttt{multigrid\_smoother} card             %
#>       \end{itemize}}
#>   }
  multigrid_cg_solver:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() sor bjacobi gmres bicgstab lu
#>
#>   {\bf multigrid\_cg\_solver\_its} multigrid\_cg\_solver\_its
#>   \VERAInputTable{
#>     name={multigrid\_cg\_solver\_its},
#>     type={Integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={15},
#>     valuesapplicable={Any positive integer.},
#>     description={Number of cg\_solver iterations to perform on coarsest grid           %
#>       of the multigrid solver.}
#>   }
  multigrid_cg_solver_its:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
  multigrid_cg_tol:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf multigrid\_cg\_solver\_1G} multigrid\_cg\_solver\_1G
#>   \VERAInputTable{
#>     name={multigrid\_cg\_solver\_1G},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={gmres},
#>     valuesapplicable={sor, bjacobi, gmres, bicgstab, or lu},
#>     limitations={},
#>     description={                                                                     %
#>       This card is used to control the solver used on the coarsest grid of            %
#>       multigrid. The options are: \begin{itemize}                                     %
#>       \item \texttt{gmres} -- Standard GMRES solver in PETSc, with a                  %
#>          preconditioner that is ILU-like locally and Jacobi-like between              %
#>          processors.                                                                  %
#>       \item \texttt{bicgstab} -- Standard BiCGSTAB solver in PETSc, same              %
#>          preconditioner as GMRES.                                                     %
#>       \item \texttt{lu} -- Exact LU solver.  In parallel, superLU package             %
#>          must be enabled to use this.                                                 %
#>       \item Any of the options for the \texttt{multigrid\_smoother} card             %
#>       \end{itemize}}
#>   }
  multigrid_cg_solver_1G:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() sor bjacobi gmres bicgstab lu
#>
#>   {\bf multigrid\_cg\_solver\_its\_1G} multigrid\_cg\_solver\_its\_1G
#>   \VERAInputTable{
#>     name={multigrid\_cg\_solver\_its\_1G},
#>     type={Integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={15},
#>     valuesapplicable={Any positive integer.},
#>     description={Number of cg\_solver iterations to perform on coarsest grid           %
#>       of the multigrid solver.}
#>   }
  multigrid_cg_solver_its_1G:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
  multigrid_cg_tol_1G:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf multigrid\_smoother} multigrid\_smoother
#>   \VERAInputTable{
#>     name={multigrid\_smoother},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={sor},
#>     valuesapplicable={sor, bjacobi},
#>     limitations={},
#>     description={This card is only used when petsc\_linear\_solver\_method is         %
#>       set to multigrid, or if petsc\_linear\_solver\_method\_1G is set to             %
#>       set to multigrid, and the corresponding 1G quantity is not available.           %
#>       The same is true of any card beginning with ``multigrid\_''.                    %
#>                                                                                       %
#>       This card is used to control the smoother used on all but the coarsest          %
#>       grid in multigrid. The options are: \begin{itemize}                             %
#>       \item \texttt{sor} -- PCSOR from PETSc.  It's not really SOR since we           %
#>         don't give it a relaxation parameter.  It is Gauss-Seidel locally             %
#>         and Jacobi between processors.                                                %
#>       \item \texttt{bjacobi} -- Block Jacobi preconditioner where each proc           %
#>         is a block in the global matrix.  Each block is partially inverted            %
#>         by an ILU iteration.  (ILU locally, Jacobi globally)                          %
#>       \end{itemize}}
#>   }
  multigrid_smoother:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() sor bjacobi
#>
#>   {\bf multigrid\_num\_smooth} multigrid\_num\_smooth
#>   \VERAInputTable{
#>     name={multigrid\_num\_smooth},
#>     type={Integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1/0},
#>     valuesapplicable={Any positive integer.},
#>     limitations={},
#>     description={This card is used to control the number of smoother                  %
#>       iterations used on each level of the multigrid scheme except the                %
#>       the coarsest.  If no value is given, it will do one smoother iteration          %
#>       on the way down and no smoother iterations on the way up.  If a value           %
#>       is given, it will do that many iterations on the way up and on the way          %
#>       down.  The only way to achieve the default behavior is to leave this            %
#>       entry blank.}
#>   }
  multigrid_num_smooth:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf multigrid\_smoother\_1G} multigrid\_smoother\_1G
#>   \VERAInputTable{
#>     name={multigrid\_smoother\_1G},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={sor},
#>     valuesapplicable={sor, bjacobi},
#>     limitations={},
#>     description={This card is only used when petsc\_linear\_solver\_method\_1G        %
#>       is set to multigrid                                                             %
#>                                                                                       %
#>       This card is used to control the smoother used on all but the coarsest          %
#>       grid in multigrid. The options are: \begin{itemize}                             %
#>       \item \texttt{sor} -- PCSOR from PETSc.  It's not really SOR since we           %
#>         don't give it a relaxation parameter.  It is Gauss-Seidel locally             %
#>         and Jacobi between processors.                                                %
#>       \item \texttt{bjacobi} -- Block Jacobi preconditioner where each proc           %
#>         is a block in the global matrix.  Each block is partially inverted            %
#>         by an ILU iteration.  (ILU locally, Jacobi globally)                          %
#>       \end{itemize}}
#>   }
  multigrid_smoother_1G:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() sor bjacobi
#>
#>   {\bf multigrid\_num\_smooth\_1G} multigrid\_num\_smooth\_1G
#>   \VERAInputTable{
#>     name={multigrid\_num\_smooth\_1G},
#>     type={Integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1/0},
#>     valuesapplicable={Any positive integer.},
#>     limitations={},
#>     description={This card is used to control the number of smoother                  %
#>       iterations used on each level of the multigrid scheme except the                %
#>       the coarsest.  If no value is given, it will do one smoother iteration          %
#>       on the way down and no smoother iterations on the way up.  If a value           %
#>       is given, it will do that many iterations on the way up and on the way          %
#>       down.  The only way to achieve the default behavior is to leave this            %
#>       entry blank.}
#>   }
  multigrid_num_smooth_1G:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf multigrid\_log\_flag} multigrid\_log\_flag
#>   \VERAInputTable{
#>     name={multigrid\_log\_flag},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={false},
#>     valuesapplicable={true or false},
#>     limitations={},
#>     description={This card must be set to true for PETSc to printout                  %
#>       performance and logging information for the multigrid solver.                   %
#>       However, setting this to true is not sufficient.  You must also                 %
#>       provide MPACT with the command line option -pc\_mg\_log at runtime.}
#>   }
  multigrid_log_flag:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf multigrid\_log\_flag\_1G} multigrid\_log\_flag\_1G
#>   \VERAInputTable{
#>     name={multigrid\_log\_flag\_1G},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={false},
#>     valuesapplicable={true or false},
#>     limitations={},
#>     description={This card must be set to true for PETSc to printout                  %
#>       performance and logging information for the multigrid solver.                   %
#>       However, setting this to true is not sufficient.  You must also                 %
#>       provide MPACT with the command line option -pc\_mg\_log at runtime.}
#>   }
  multigrid_log_flag_1G:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf multigrid\_precond\_flag} multigrid\_precond\_flag
#>   \VERAInputTable{
#>     name={multigrid\_precond\_flag},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={false},
#>     valuesapplicable={true or false},
#>     limitations={},
#>     description={Setting this card to true makes the code use multigrid as a
#>       preconditioner to GMRES rather than as a standalone solver.}
#>   }
  multigrid_precond_flag:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf multigrid\_precond\_flag\_1G} multigrid\_precond\_flag\_1G
#>   \VERAInputTable{
#>     name={multigrid\_precond\_flag\_1G},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={false},
#>     valuesapplicable={true or false},
#>     limitations={},
#>     description={Setting this card to true makes the code use multigrid as a
#>       preconditioner to GMRES rather than as a standalone solver.}
#>   }
  multigrid_precond_flag_1G:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf multigrid\_cg\_solver\_its} multigrid\_cg\_solver\_its
#>   \VERAInputTable{
#>     name={multigrid\_cg\_solver\_its},
#>     type={Integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={15},
#>     valuesapplicable={Any positive integer.},
#>     description={Number of cg\_solver iterations to perform on coarsest grid           %
#>       of the multigrid solver.}
#>   }
  preconditioner:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() default ilu bilu bjacobi_ilu mg eisenstat none
#>
#>   {\bf cmfd\_eigen\_solver} cmfd\_eigen\_solver
#>   \VERAInputTable{
#>     name={cmfd\_eigen\_solver},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={power},
#>     valuesapplicable={JD, GD, Arnoldi SLEPc\_power described as:                      %
#>       \begin{itemize}                                                                 %
#>         \item \texttt{power} --- Standard power iteration.                            %
#>         \item \texttt{JD} --- SLEPc Jacobi-Davidson Solver.                           %
#>         \item \texttt{GD} --- SLEPc or Anasazi Generalized Davidson Solver depends on cmfd\_linear\_solver.  %
#>         \item \texttt{Arnoldi} --- SLEPc Arnoldi Solver.                              %
#>         \item \texttt{SLEPc\_power} --- SLEPc power iteration for comparison.         %
#>       \end{itemize}},
#>     limitations={},
#>     description={This card is used to specify which eigenvalue solver will be used.},
#>     notes={CMFD must be present for every 3-D problem because it is the basis         %
#>       for the solution transfer between 2-D and 1-D.}
#>   }
  cmfd_eigen_solver:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() power jd gd arnoldi slepc_power nonlin
#>
#>   {\bf k\_shift} k\_shift
#>   \VERAInputTable{
#>     name={k\_shift},
#>     type={Floating-Point Real Number},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1.5},
#>     valuesapplicable={},
#>     limitations={Can only be used with the mgnode CMFD solver.  This card             %
#>       is irrelevant unless the \texttt{constant} option is used for the               %
#>       \texttt{cmfd\_shift\_method} card.},
#>     description={This card is used to specify a shifted eigenvalue problem            %
#>       for the CMFD power iterations.},
#>     notes={\texttt{k\_shift} should be larger than the eigenvalue of the              %
#>       system.  Even a value of 2 would provide some enhanced convergence              %
#>       properties over not using \texttt{k\_shift}.}
#>   }
  k_shift:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_geq() 0.0
#>
#>   {\bf k\_shift\_1G} k\_shift\_1G
#>   \VERAInputTable{
#>     name={k\_shift\_1G},
#>     type={Floating-Point Real Number},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1.5},
#>     valuesapplicable={},
#>     limitations={Can only be used with the mgnode CMFD solver.  This card             %
#>       is irrelevant unless the \texttt{constant} option is used for the               %
#>       \texttt{cmfd\_shift\_method\_1G} card and the \texttt{msed} option              %
#>       is used for the \texttt{cmfd} card.},
#>     description={This card is used to specify a shifted eigenvalue problem            %
#>       for the 1G CMFD power iterations.},
#>     notes={\texttt{k\_shift\_1G} should be larger than the eigenvalue of the              %
#>       system.  Even a value of 2 would provide some enhanced convergence              %
#>       properties over not using \texttt{k\_shift\_1G}.}
#>   }
  k_shift_1G:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_geq() 0.0
#>
#>   {\bf cmfd\_relaxation} cmfd\_relaxation
#>   \VERAInputTable{
#>     name={cmfd\_relaxation},
#>     type={Floating-Point Real Number},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1.0},
#>     valuesapplicable={},
#>     limitations={}
#>     description={This card is for specifying the relaxation parameter for   %
#>       the CMFD flux update. The default value (1.0) corresponds to no
#>       relaxation of the update. Values below 1.0 under-relax the CMFD flux  %
#>       update to provide stability for cases with T/H or other feedback. For %
#>       standalone neutronics problems, no under-relaxation should be needed  %
#>       to achieve stability when using the adCMFD option, and any            %
#>       under-relaxation will probably degrade the converegence rate.}
#>   }
  cmfd_relaxation:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf cmfd\_dhat\_relaxation} cmfd\_dhat\_relaxation
#>   \VERAInputTable{
#>     name={cmfd\_dhat\_relaxation},
#>     type={Floating-Point Real Number},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1.0},
#>     valuesapplicable={},
#>     limitations={},
#>     description={This card is for specifying the relaxation parameter for   %
#>       the CMFD dHat update. The default value (1.0) corresponds to no       %
#>       relaxation of the update. Values below 1.0 under-relax the CMFD dHat  %
#>       update to provide stability for cases with very large flux gradients. %
#>       For typical neutronics problems, no under-relaxation should be needed %
#>       to achieve stability when using the CMFD option, and any              %
#>       under-relaxation will probably degrade the converegence rate.  When   %
#>       running an external source driven problem, under-relaxation may be    %
#>       necessary to obtain convergence, In the most extreme cases,           %
#>       under-relaxation may be set to 0.0, which effectively removes the     %
#>       dHat correction coefficient in the CMFD calculation, and results in   %
#>       CMFD calculating a more traditional diffusion solution.  When running %
#>       with no dHat correction coefficient, the equivalence between CMFD     %
#>       and fine mesh transport solutions is no longer garuanteed!}
#>   }
  cmfd_dhat_relaxation:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_geq() 0.0
#>
#>   {\bf cmfd\_shift\_c0} cmfd\_shift\_c0
#>   \VERAInputTable{
#>     name={cmfd\_shift\_c0},
#>     type={Floating-Point Real Number},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={0.02}
#>     valuesapplicable={All positive real numbers},
#>     limitations={Can only be used with the mgnode CMFD solver.  This card             %
#>       is irrelevant unless the adaptive, ileps, or ilaps shift is being used.},
#>     description={This card is used to specify the c0 parameter used in the            %
#>       adaptive/ileps/ilaps shift.  c0 is used to reduce the shift to ensure           %
#>       both a positive fission source and a subcritical diffusion operator             %
#>       (i.e., to prevent overshifting).},
#>     notes={}
#>   }
  cmfd_shift_c0:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf cmfd\_dhat\_relaxation} cmfd\_dhat\_relaxation
#>   \VERAInputTable{
#>     name={cmfd\_dhat\_relaxation},
#>     type={Floating-Point Real Number},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1.0},
#>     valuesapplicable={},
#>     limitations={},
#>     description={This card is for specifying the relaxation parameter for   %
#>       the CMFD dHat update. The default value (1.0) corresponds to no       %
#>       relaxation of the update. Values below 1.0 under-relax the CMFD dHat  %
#>       update to provide stability for cases with very large flux gradients. %
#>       For typical neutronics problems, no under-relaxation should be needed %
#>       to achieve stability when using the CMFD option, and any              %
#>       under-relaxation will probably degrade the converegence rate.  When   %
#>       running an external source driven problem, under-relaxation may be    %
#>       necessary to obtain convergence, In the most extreme cases,           %
#>       under-relaxation may be set to 0.0, which effectively removes the     %
#>       dHat correction coefficient in the CMFD calculation, and results in   %
#>       CMFD calculating a more traditional diffusion solution.  When running %
#>       with no dHat correction coefficient, the equivalence between CMFD     %
#>       and fine mesh transport solutions is no longer garuanteed!}
#>   }
  cmfd_shift_method:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() none constant adaptive sdws-ileps sdws-ilaps sdws-laps
#>
#>   {\bf cmfd\_shift\_method\_1G} cmfd\_shift\_method\_1G
#>   \VERAInputTable{
#>     name={cmfd\_shift\_method\_1G},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={constant},
#>     valuesapplicable={none, adaptive, sdws-ileps, sdws-ilaps, sdws-laps.  See         %
#>       texttt{cmfd\_shift\_method} card for description.  This card is only            %
#>       applicable if a 1G CMFD system is being used to accelerate the MG CMFD          %
#>        system.},
#>     limitations={ This card is only used if the CMFD card is set to msed },           %
#>     description={ This card is used to specify which wielandt shift method            %
#>       will be used to accelerate the power iterations on the 1G CMFD problem.},
#>     notes={}
#>   }
  cmfd_shift_method_1G:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() none constant adaptive sdws-ileps sdws-ilaps sdws-laps

#>
#>   {\bf cmfd\_ktol} cmfd\_ktol
#>   \VERAInputTable{
#>    name={cmfd\_ktol},
#>    type={Floating Point Number},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={1.e-6},
#>    valuesapplicable={Any positive value.},
#>    limitations={},
#>    description={This card is used to specify the tolerance for the                    %
#>      convergence of k in the overall CMFD eigenavlue problem.},
#>   }
  cmfd_ktol:
      <<: *dtdouble
      _content:
      _check:
        - is_float()
        - is_gt() 0.0

#>
#>   {\bf cmfd\_rtol} cmfd\_rtol
#>   \VERAInputTable{
#>    name={cmfd\_rtol},
#>    type={Floating Point Number},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={1.e-6},
#>    valuesapplicable={Any positive value.},
#>    limitations={},
#>    description={This card is used to specify the tolerance for the                    %
#>      relative residual reduction in a CMFD linear system solved each power iteration.},
#>   }
  cmfd_rtol:
      <<: *dtdouble
      _content:
      _check:
        - is_float()
        - is_gt() 0.0

#>
#>   {\bf cmfd\_ktol\_1G} cmfd\_ktol\_1G
#>   \VERAInputTable{
#>    name={cmfd\_ktol\_1G},
#>    type={Floating Point Number},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={1.e-6},
#>    valuesapplicable={Any positive value.},
#>    limitations={},
#>    description={This card is used to specify the tolerance for the                    %
#>      convergence of k in the 1G CMFD eigenavlue problem in MSED.},
#>   }
  cmfd_ktol_1G:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf cmfd\_flxtol\_1G} cmfd\_flxtol\_1G
#>   \VERAInputTable{
#>    name={cmfd\_flxtol\_1G},
#>    type={Floating Point Number},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={1.e-6},
#>    valuesapplicable={Any positive value.},
#>    limitations={},
#>    description={This card is used to specify the tolerance for the                    %
#>       convergence of the flux in the 1G CMFD eigenavlue problem in MSED.},
#>   }
  cmfd_flxtol_1G:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf max\_1G\_eig\_its} max\_1G\_eig\_its
#>   \VERAInputTable{
#>     name={max\_1G\_eig\_its},
#>    type={Integer},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={20},
#>    valuesapplicable={Any positive value.},
#>    limitations={},
#>    description={This card is used to specify the maximum number of power              %
#>      power iterations allowed on the 1G CMFD system in MSED.},
#>   }
  max_1G_eig_its:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf cmfd\_num\_inners} cmfd\_num\_inners
#>   \VERAInputTable{
#>     name={cmfd\_num\_inners},
#>    type={Integer},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={100},
#>    valuesapplicable={Any positive integer.},
#>    limitations={},
#>    description={This card is used to specify the max. number of linear solver         %
#>      iterations per power iteration during a CMFD acceleration calculation.},
#>   }
  cmfd_num_inners:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf cmfd\_num\_inners\_1G} cmfd\_num\_inners\_1G
#>   \VERAInputTable{
#>     name={cmfd\_num\_inners\_1G},
#>    type={Integer},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={100},
#>    valuesapplicable={Any positive integer.},
#>    limitations={},
#>    description={This card is used to specify the maximum number of linear             %
#>      solver iterations allowed per power iterations in the 1G CMFD system             %
#>      in MSED.},
#>   }
  cmfd_num_inners_1G:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() -1
#>
#>   {\bf linear\_solver\_tol} linear\_solver\_tol
#>   \VERAInputTable{
#>     name={linear\_solver\_tol},
#>    type={Floating Point Number},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={1.e-10},
#>    valuesapplicable={Any positive value.},
#>    limitations={},
#>    description={This card is used to specify the tolerance of linear solver          %
#>      used at each power iteration during a CMFD acceleration calculation.},
#>   }
  linear_solver_tol:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
#>
#>   {\bf linear\_solver\_tol\_1G} linear\_solver\_tol\_1G
#>   \VERAInputTable{
#>     name={linear\_solver\_tol\_1G},
#>    type={Floating Point Number},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={1.e-10},
#>    valuesapplicable={Any positive value.},
#>    limitations={},
#>    description={This card is used to specify the tolerance of linear solver          %
#>      used at each power iteration on the 1G system in MSED.},
#>   }
  linear_solver_tol_1G:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
#>
#>   {\bf cmfd\_num\_outers} cmfd\_num\_outers
#>   \VERAInputTable{
#>     name={cmfd\_num\_outers},
#>    type={Integer},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={20},
#>    valuesapplicable={Any positive value.},
#>    limitations={},
#>    description={This card is used to specify the number of outer eigenvalue           %
#>      power iterations to perform during a CMFD acceleration calculation.},
#>   }
  cmfd_num_outers:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf cmfd\_up\_scatter} cmfd\_up\_scatter
#>   \VERAInputTable{
#>     name={cmfd\_up\_scatter},
#>    type={Integer},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={2},
#>    valuesapplicable={Any positive integer.},
#>    limitations={Only applies to \texttt{1gsweep} CMFD solver.},
#>    description={This card is used to specify the number of upscatter                  %
#>      iterations when doing \texttt{1gsweep} CMFD. This can help to converge the       %
#>      scattering source in thermal energy groups before updating the fission source.   %
#>      In general, this can be used to help optimize run time for a given problem.},
#>    notes={}
#>   }
  cmfd_up_scatter:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
  cmfd_ur:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf subplane\_target} subplane\_target
#>   \VERAInputTable{
#>     name={subplane\_target},
#>     type={Floating-Point Real Number},
#>     need={Optional},
#>     unitsdefault={cm},
#>     unitsother={},
#>     valuedefault={N/A},
#>     valuesapplicable={Positive real numbers},
#>     limitations={},
#>     description={This card is used to designate the target thickness of axial         %
#>       meshes in the CMFD system.},
#>     notes={}
#>   }
  subplane_target:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
#>
#>   {\bf subplane\_max} subplane\_max
#>   \VERAInputTable{
#>     name={subplane\_max},
#>     type={Floating-Point Real Number},
#>     need={Optional},
#>     unitsdefault={cm},
#>     unitsother={},
#>     valuedefault={N/A},
#>     valuesapplicable={Positive real numbers},
#>     limitations={},
#>     description={This card is used to designate the maximum thickness of axial        %
#>       meshes in the CMFD system. All MOC planes with thicknesses greater than         %
#>       this will be sub-divided in the CMFD system using the                           %
#>       \texttt{subplane\_target} value.},
#>     notes={}
#>   }
  subplane_max:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0

#>
#>   {\bf subgrid\_spacers} subgrid\_spacers
#>   \VERAInputTable{
#>     name={subgrid\_spacers},
#>     type={Logical},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={false},
#>     valuesapplicable={true,false},
#>     limitations={},
#>     description={This card is used to designate whether or not spacer grids are       %
#>       used in subgrid solver setup,
#>     notes={}
#>   }
  subgrid_spacers:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false

#>
#>   {\bf num\_subplanes} num\_subplanes
#>   \VERAInputTable{
#>     name={num\_subplanes},
#>     type={Integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={1},
#>     valuesapplicable={$>$0},
#>     limitations={},
#>     description={Thsi card is used to designate the number of subplanes used          %
#>       for each MOC plane in the CMFD system.  Every MOC plane will be split           %
#>       into \texttt{num\_subplanes} subplanes.  This card overrides both the           %
#>       \texttt{subplane\_target} and \texttt{subplane\_max} cards.  Any of             %
#>       these cards may be used to control the subplane meshing, but this card          %
#>       is recommended since the other two result in parallel imbalance.},
#>     notes={}
#>   }
  num_subplanes:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf cmfd\_angle\_decomp} cmfd\_angle\_decomp
#>   \VERAInputTable{
#>     name={cmfd\_angle\_decomp},
#>     type={Logical},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={true},
#>     valuesapplicable={false},
#>     limitations={If angle decomposition or CMFD is not used this card has no effect.},
#>     description={This card is used to specify whether or not the angular              %
#>       decomposition processors for MOC are to be used during the CMFD setup/solve.    %
#>       The default for this treatment is \texttt{true}, and is recommended for         %
#>       better parallel efficiency.},
#>     notes={}
#>   }
  cmfd_angle_decomp:
    <<: *dtword
    _content:
    _check:
     - is_word()
     - in_dictionary() true false
#>
#>   {\bf split\_TL} split\_TL
#>   \VERAInputTable{
#>     name={split\_TL},
#>    type={Logical},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={true},
#>    valuesapplicable={false},
#>    limitations={Only applies to 3-D models run with 2-D/1-D.},
#>    description={This card is used to specify whether transverse leakage               %
#>      splitting will be enabled for a calculation using a 2-D/1-D method. \newline     %
#>      \newline                                                                         %
#>      In the 2-D/1-D method the axial transverse leakage is subtracted from the total  %
#>      fission and scattering sources, thus in regions with relatively large axial      %
#>      streaming sources, the total source may become negative. To avoid negative       %
#>      total sources the transverse leakage is split between the right hand side and    %
#>      left hand side of the 2-D transport equation, thus ensuring positivity of the    %
#>      total source and neutron balance.},
#>    notes={}
#>   }
  split_TL:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
  split_RTL:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf TL\_treatment} TL\_treatment
#>   \VERAInputTable{
#>     name={TL\_treatment},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={lflat},
#>     valuesapplicable={flat.  These are described as:                                  %
#>       \begin{itemize}                                                                 %
#>         \item \texttt{lflat} --- checks the total / transport cross section.          %
#>           If the value is below the threshold, leakage will not be put into           %
#>           that region.  This process is usually to avoid leakage in the fuel-         %
#>           clad gap.  It will then redistribute the leakage to the other               %
#>           regions in that pin.                                                        %
#>         \item \texttt{flat} --- does not perform leakage threshold checks.            %
#>       \end{itemize}},
#>     limitations={},
#>     description={This card is used to specify the type of spatial shape of the        %
#>       axial transverse leakage applied to the 2-D problem. Flat means it is constant  %
#>       over a pin cell. This is primarily used to ensure stability of the iteration.},
#>     notes={}
#>   }
  TL_treatment:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() flat lflat
#>
#>   {\bf nodal\_method} nodal\_method
#>   \VERAInputTable{
#>    name={nodal\_method},
#>    type={Fixed Character String},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={sp3},
#>    valuesapplicable={sanm, sn-0, sn-1, sn-2, sn-3, p1, p3, p5, hyp3,          %
#>      fhp1, fhp3, none. \newline \newline Described as:                                %
#>      \newline                                                                         %
#>      \centering                                                                       %
#>        \begin{tabular}{ll}                                                            %
#>          \hline                                                                       %
#>            Input Option & Full Name \\                                                %
#>          \hline                                                                       %
#>            SANM & Semi-Analytic Nodal Method \\                                       %
#>            NEM & Nodal Expansion Method \\                                            %
#>            NEM-MG & Multi-Group Nodal Expansion Method \\                             %
#>            SN-0 & Discrete Ordinates with 0th Spatial Moment\\                      %
#>            SN-1 & Discrete Ordinates with 1st Spatial Moment\\                      %
#>            SN-2 & Discrete Ordinates with 2nd Spatial Moment\\                      %
#>            SN-3 & Discrete Ordinates with 3rd Spatial Moment\\                      %
#>            P1 & Pn 1st Order with One-Node NEM\\                                      %
#>            P3 & Pn 3rd Order with One-Node NEM\\                                      %
#>            P5 & Pn 5th Order with One-Node NEM\\                                      %
#>            HYP3 & Hybrid Pn 3rd Order with NEM\\                                      %
#>            FHP1 & 1st Order with Full Height NEM\\                                    %
#>            FHP3 & 3rd Order with Full Height NEM\\                                    %
#>            NONE & Finite-Difference Method\\                                          %
#>          \hline                                                                       %
#>        \end{tabular}},
#>    limitations={Only applies to 3-D models run with 2-D/1-D.},
#>    description={This card is used to specify the type of nodal axial solver           %
#>      that will be used to solve the 1-D portion of the 2-D/1-D solution.},
#>    notes={The Sn methods are the most computationally intensive. SP3 is recommended   %
#>      as the best balance of accuracy and speed. If convergence/stability issues       %
#>      are encountered with SP3, then try running with NEM.}
#>   }
  nodal_method:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() nem sanm nem-mg sp1 sp3 sp5 hysp3 fhp3 p1 p2 p3 hyp3 sn-0 sn-1 sn-2 sn-3 p3-mom none
  sntype:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() isotropic aziint explicit moment p3-moment none
  rtltype:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() isotropic aziint explicit moment p3-moment p3-quad p3-quadratic p3-even sym none
  atltype:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() isotropic aziint explicit moment azi exp mom sym none
  rtlmom:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_geq() 0
  homtype:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() isotropic polar moment explicit symmetric none
  under_relax:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0.0
      - is_lt() 2.0
#>
#>   {\bf mesh} mesh
#>   \VERAInputTable{
#>     name={mesh},
#>     type={Fixed Character String Followed by Two Arrays of Integers Separated         %
#>       by a `/'},
#>     need={Required},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={num\_rad = 3, 1 and num\_azi = 1, 8, 8, 8, 12},
#>     valuesapplicable={For \texttt{num\_rad}, positive integers greater than zero.     %
#>       For \texttt{num\_azi}, 1, 4, 8, 12, or 16. The length for \texttt{num\_rad}     %
#>       is the number of geometric radii, and the length for \texttt{num\_azi} is the   %
#>       sum of the sub-divided radii.},
#>     limitations={},
#>     description={This card is used to specify the radial and azimuthal mesh           %
#>       for each cell. Currently two cell types are used: \texttt{fuel} and             %
#>       \texttt{gtube}. Cells containing fuel materials are flagged to use the          %
#>       \texttt{fuel} mesh and all other cells use the \texttt{gtube meshing}.  For     %
#>       the inputs, \texttt{num\_rad} is the number of radial subdivisions in each      %
#>       ring specified in the cell and \texttt{num\_azi} is the number of azimuthal     %
#>       regions in each sub-divided radial ring.  The last azimuthal value applies to   %
#>       the region outside the pin.},
#>     notes={Currently insert, control, and detector rods have predefined mesh          %
#>       that cannot be overwritten.                                                     %
#>       \newline\newline                                                                %
#>       In both cases, the last entry will be used for any remaining                    %
#>       unspecified regions.  For example, if a given fuel pin has 3 radial and         %
#>       material regions, and the fuel mesh had a num\_rad of 3,1 and num\_azi          %
#>       of 1,4,8, then the third ring in the fuel pin would have 1 radial               %
#>       sub-division, and the fourth subdivided radius to the end of the pin            %
#>       cell would have 8 azimuthal sub-divisions, including the region                 %
#>       outside the pincell.                                                            %
#>       \newline\newline                                                                %
#>       If the mesh is specified too finely, or rather, finer than                      %
#>       the value for ray spacing, instabilities may occur where a ray is NOT           %
#>       traced through a flat source region and no flux is calculated for that          %
#>       region.  The code will automatically adjust the azimuthal discretization        %
#>       if the given ray spacing value is too coarse (or because the azimuthal mesh     %
#>       is too fine).  Another way to cause the above instability would be to           %
#>       specify a very large number of radial subdivisions for the first                %
#>       \texttt{num\_rad value}.  That large number being the area of the first radius  %
#>       divided by the first \texttt{num\_rad} value would have to yield a radius that  %
#>       is smaller than the ray spacing.  For a typical PWR fuel pin radius, the        %
#>       first \texttt{num\_rad value} needs to be well over 100 for this problem to     %
#>       arise, and this number is impractical given the memory it will consume.}
#>   }
  mesh:
    <<: *dtlistnamed
    _slash:
    _check:

  db_entry:
    <<: *dtlistnamed
    _slash:
    _check:
#>
#>   {\bf prompt} prompt
#>   \VERAInputTable{
#>     name={prompt},
#>     type={Fixed Character String},
#>     need={Required},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={\texttt{true}},
#>     limitations={},
#>     description={This option is used to specify whether to use         %
#>       prompt kinetics calculation during the transient solver. The default is %
#>       true. For now, this option is set to be true, no matter which option    %
#>       is input.},
#>     notes={}
#>   }
  prompt:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf cmfd\_shift\_method\_1G} cmfd\_shift\_method\_1G
#>   \VERAInputTable{
#>     name={cmfd\_shift\_method\_1G},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={constant},
#>     valuesapplicable={none, adaptive, sdws-ileps, sdws-ilaps, sdws-laps.  See         %
#>       texttt{cmfd\_shift\_method} card for description.  This card is only            %
#>       applicable if a 1G CMFD system is being used to accelerate the MG CMFD          %
#>        system.},
#>     limitations={ This card is only used if the CMFD card is set to msed },           %
#>     description={ This card is used to specify which wielandt shift method            %
#>       will be used to accelerate the power iterations on the 1G CMFD problem.},
#>     notes={}
#>   }
  accel:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false

  1gacceltr:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false

  1gaccel:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false

  tml1gmg:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf delayenergy} delayenergy
#>   \VERAInputTable{
#>     name={delayenergy},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={false},
#>     valuesapplicable={\texttt{true}},
#>     limitations={},
#>     description={This option is used to specify whether to use         %
#>       explicit delayed energy kernel during the transient solver. The default  %
#>       is false. The equilibrium delayed energy (about 7 percent of total fission energy %
#>       including delayed beta and gamma) is assumed in default.},
#>     notes={}
#>   }
  delayenergy:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf kinetics\_data} kinetics\_data
#>   \VERAInputTable{
#>     name={kinetics\_data},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={library},
#>     valuesapplicable={scale,keepin,tuttle,jeff3,santamarina,library,spert70f,spert250f,spert500f. These are described as:  %
#>       \begin{enumerate}
#>         \item \texttt{scale} --- the 6-group transient data from SCALE        %
#>         \item \texttt{keepin} --- the 6-group transient data from G. R. Keepin's paper   %
#>         \item \texttt{tuttle} --- the 6-group transient data from R. J. Tuttle's paper   %
#>         \item \texttt{jeff3} --- the 8-group transient data from JEFF3 with uniform lambda   %
#>         \item \texttt{santamarina} --- the 8-group transient data suggested by A. Santamarina (a slight modification of JEFF3)   %
#>         \item \texttt{library} --- the 6-group transient data in MPACT cross section library from ENDF        %
#>         \item \texttt{spert70f,spert250f,spert500f} --- the 6-group transient data measured in spert experiments   %
#>       \end{enumerate}},
#>     limitations={},
#>     description={This card is used to specify the set of kinetics data used in transient calculation. %
#>         This card is only applied to MPACT cross section library for now. By default,               %
#>         MPACT uses the 6-group transient data provided in MPACT MG cross section library.},
#>     notes={}
#>   }
  kinetics_data:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() scale keepin tuttle jeff3 santamarina library spert70f spert250f spert500f
#>
#>   {\bf kinetics\_lambda} kinetics\_lambda
#>   \VERAInputTable{
#>     name={kinetics\_lambda},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={fissweight},
#>     valuesapplicable={isotopic,fissweight,precursorconsv. These are described as:  %
#>       \begin{enumerate}
#>         \item \texttt{isotopic} --- use exact isotope dependent lambdas        %
#>         \item \texttt{fissweight} --- collapse isotopic lambdas by fission rate   %
#>         \item \texttt{precursorconsv} --- collapse isotopic lambdas by preserving the initial precursors   %
#>       \end{enumerate}},
#>     limitations={},
#>     description={This card controls the calculation of decay constant for each fissile region. %
#>         The isotopic lambda is the exact approach, but can use a lot more memories.      %
#>         In general, it is recommended to use precursor conservation option rather than fission source weighting.},
#>     notes={}
#>   }
  kinetics_lambda:
    <<: *dtword
    _content:
    _check:
      - is_word()
      - in_dictionary() isotopic fissweight precursorconsv
#>
#>   {\bf kinetics\_otfbeta} kinetics\_otfbeta
#>   \VERAInputTable{
#>     name={kinetics\_otfbeta},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={false},
#>     valuesapplicable={\texttt{true}},
#>     limitations={},
#>     description={This option specifies whether to compute the problem dependent      %
#>       nubar for on-the-fly calculation of beta. By default, problem-independent beta %
#>       computed from a typical PWR spectrum is used.},
#>     notes={}
#>   }
  kinetics_otfbeta:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf rx\_components} rx\_components
#>   \VERAInputTable{
#>     name={rx\_components},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={\texttt{true}},
#>     limitations={Can only be used when acceleration is enabled.},
#>     description={This option is used to specify whether to         %
#>       calculate component reactivity values. The default is false. %
#>       This option is ignored for steadystate calculations.},
#>     notes={}
#>   }
  rx_components:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false

  sep_flux_comp:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf summary\_edits} summary\_edits
#>   \VERAInputTable{
#>     name={summary\_edits},
#>     type={Fixed Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={\texttt{true}},
#>     limitations={Only used for transient cases.},
#>     description={This option is used to specify whether to         %
#>       print a summary file (<caseid>.sum) containing data for each %
#>       transient timestep. The default is false. This option is     %
#>       ignored for steadystate calculations.},
#>     notes={}
#>   }
  summary_edits:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
#>
#>   {\bf split\_TL} split\_TL
#>   \VERAInputTable{
#>     name={split\_TL},
#>    type={Logical},
#>    need={Optional},
#>    unitsdefault={},
#>    unitsother={},
#>    valuedefault={true},
#>    valuesapplicable={false},
#>    limitations={Only applies to 3-D models run with 2-D/1-D.},
#>    description={This card is used to specify whether transverse leakage               %
#>      splitting will be enabled for a calculation using a 2-D/1-D method. \newline     %
#>      \newline                                                                         %
#>      In the 2-D/1-D method the axial transverse leakage is subtracted from the total  %
#>      fission and scattering sources, thus in regions with relatively large axial      %
#>      streaming sources, the total source may become negative. To avoid negative       %
#>      total sources the transverse leakage is split between the right hand side and    %
#>      left hand side of the 2-D transport equation, thus ensuring positivity of the    %
#>      total source and neutron balance.},
#>    notes={}
#>   }
  tml:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false

  tmllevel:
    <<: *dtlist
    _content:
    _check:
      - fall(sub{is_int(shift)})
      - fall(sub{is_geq(shift,0)})
#>
#>   {\bf transmethod} transmethod
#>   \VERAInputTable{
#>     name={transmethod},
#>     type={Fixed Character Array, Postive Real Number or Integer. Length 1 },
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={\texttt{\{theta 0.5\}}},
#>     valuesapplicable={The first option is used to specify time the          %
#>       discretization method, \texttt{theta} refers to theta method and      %
#>       \texttt{BDF} refer to BDF method.\newline The \texttt{<value>}        %
#>       defines the option for the theta method [0.0,1.0] or the BDF method.  %
#>       For the BDF method, the value is an integer that ranges from 1 to 6.  %
#>       If only BDF is specified, the default order is 2},
#>     limitations={},
#>     description={},
#>     notes={}
#>   }
  transmethod:
    <<: *dtlist
    _content:
    _check:
      - is_word(nth(0,()))
      - in_dictionary(nth(0,()),'theta','bdf')
      - is_float(nth(1,()))
      - is_geq(nth(1,()),0)
#>
#>   {\bf timestep} timestep
#>   \VERAInputTable{
#>     name={timestep},
#>     type={Fixed double precision numbers. Length 3},
#>     need={Optional},
#>     unitsdefault={seconds},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={
#>      \begin{itemize}                                                       %
#>         \item \texttt{<dt>} --- the standard time step for transient calculation %
#>         \item \texttt{<dt\_min>} --- the minimum time step for transient calculation %
#>         \item \texttt{<t\_max>} --- the end time for the transient %
#>       \end{itemize}},
#>     limitations={},
#>     description={This is used for defining the time steps and transient simulation time},
#>     notes={Presently \texttt{<dt\_min>} is ignored.}
#>   }
  timestep:
    <<: *dtlist
    _content:
    _check:
      - is_float(nth(0,()))
      - is_float(nth(1,()))
      - is_float(nth(2,()))
      - nth(0,())>0
      - nth(1,())>0
      - nth(2,())>0
#>
#>   {\bf perturb} perturb
#>   \VERAInputTable{
#>     name={perturb},
#>     type={Array of String and doubles},
#>     need={Required},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={},
#>     valuesapplicable={    This card is used to specify the parameters for drive the   %
#>       transient. The options for perturbing the system are as follows:                %
#>       \begin{itemize}                                                                 %
#>         \item \texttt{t1}    --- The start time of perturbation                       %
#>         \item \texttt{t2}    --- The end time of perturbation                         %
#>         \item \texttt{dt}    --- The time step of perturbation (optional)             %
#>       \end{itemize}                                                                   %
#>       For the option \texttt{mat}, its interpretation varies with the perturbation type. %
#>       \begin{itemize}                                                                 %
#>         \item \texttt{STEP}  --- For this perturbation type, the initial condition    %
#>            for the ith material is \texttt{mat0(i)}, at time \texttt{t2}, it is turned %
#>            into \texttt{mat0} instantaneously.                                        %
#>         \item \texttt{RAMP}  --- For this perturbation type, the initial condtion     %
#>            for the ith material is \texttt{mat0(i)}. Then it changes gradualy from    %
#>            \texttt{mat1(i)} to \texttt{mat2(i)}. This change is a fractional time     %
#>            weighted mixture of the two materials. The mixture at \texttt{t1} is       %
#>            only \texttt{mat1}, halfway through the perturbation it is 0.5             %
#>            \texttt(mat1) and 0.5 \texttt{mat2}.  At the end of the perturbation,      %
#>            it is only \texttt{mat2}.                                                  %
#>         \item \texttt{CONST} --- For this perturbation there are no changes to the    %
#>               system.                                                                 %
#>         \item \texttt{MVCR} --- This perturbation is for moving a bank of control     %
#>            rods. The rod positions are specified in [STATE] blocks corresponding to   %
#>            each time step occuring during the perturbation.                           %
#>       \end{itemize}},
#>     limitations={},
#>     description={},
#>     notes={}
#>   }
  perturb:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - arraysize()%7==0
      - fall(sub{is_float(shift)},stride(0,7,()))
      - fall(sub{is_geq(shift,0)},stride(0,7,()))
      - fall(sub{is_float(shift)},stride(1,7,()))
      - fall(sub{is_geq(shift,0)},stride(1,7,()))
      - fall(sub{is_float(shift)},stride(2,7,()))
      - fall(sub{is_geq(shift,0)},stride(2,7,()))
      - fall(sub{is_word(shift)},stride(3,7,()))
      - fall(sub{in_dictionary(shift,'step','const','ramp','mvcr')},stride(3,7,()))
      - fall(sub{is_word(shift)},stride(4,7,()))
      - fall(sub{is_word(shift)},stride(5,7,()))
      - fall(sub{is_word(shift)},stride(6,7,()))
#>
#>   {\bf mat\_emit\_src} mat\_emit\_src
#>   \VERAInputTable{
#>     name={mat\_emit\_src},
#>     type={Fixed Character String.},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={\texttt{false}},
#>     valuesapplicable={This option is used to specify whether or not neutron %
#>     emission sources from the decay of model materials will be treated.     %
#>     The default is set to false.},
#>     limitations={Should only be used for subcritical systems otherwise no %
#>     steady state solution will ever be achieved},
#>     description={When just \texttt{mat\_emit\_src} is input without \texttt{true|false}, the  %
#>       option is set to \texttt{false}.},
#>     notes={}
#>   }
  mat_emit_src:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false

MAMBA:
  A_NiFe2O4_out:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  E_NiFe2O4_out:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  A_NiFe2O4_in:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  E_NiFe2O4_in:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  ksnb_Fe2O4:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  D_Ni:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  D_Fe:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  D_BOH3:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  D_Li:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  D_H2:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  CRUD_porosity:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  CRUD_solid_dens:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  CRUD_dep_frac:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  chimney_htc:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  chimney_dens:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  chimney_rad:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  chimney_vf:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
      - is_lt() 1
  CRUD_therm_cond:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  CRUD_heat_capacity:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0y
  tke_scale:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  src_mult_A:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  src_mult_E:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  steam_generator_age:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_geq() 0
  piping_age:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_geq() 0
  chem_mass_bal:
    <<: *dtint
    _content:
    _check:
      - is_geq() 0
      - is_int()
  model_erosion:
    <<: *dtint
    _content:
    _check:
      - is_geq() 0
      - is_int()
  li_table:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - arraysize()%2==0
      - fall(sub{is_float(shift)},stride(0,2,()))
      - fall(sub{is_float(shift)},stride(1,2,()))
      - fall(sub{is_geq(shift,0)},stride(0,2,()))
      - fall(sub{is_geq(shift,0)},stride(1,2,()))

BISON:

  auxkernels_pelletid_a_lower:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  auxkernels_pelletid_a_upper:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  auxkernels_fissionrateaux_value:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  auxkernels_fissionrateaux_function:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  auxkernels_fast_neutron_flux_rod_ave_lin_pow:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  auxkernels_fast_neutron_flux_axial_power_profile:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  auxkernels_fast_neutron_flux_factor:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  auxkernels_fuel_porosity_execute_on:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  auxkernels_hydrostatic_stress_execute_on:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  auxkernels_grain_radius_execute_on:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  auxkernels_hoop_stress_execute_on:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  auxkernels_radial_stress_execute_on:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  auxkernels_axial_stress_execute_on:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  auxkernels_hoop_execute_on:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  auxkernels_radial_execute_on:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  auxkernels_axial_execute_on:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  auxkernels_vonmises_execute_on:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  auxkernels_creep_strain_mag_execute_on:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  auxkernels_creep_strain_radial_execute_on:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  auxkernels_creep_strain_axial_execute_on:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  auxvariables_htcl_initial_condition:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  auxvariables_htcv_initial_condition:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  auxvariables_Tl_initial_condition:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  auxvariables_Tv_initial_condition:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  auxvariables_grain_radius_initial_condition:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  auxvariables_casl_clad_surface_temperature:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  auxvariables_porosity_initial_condition:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  bcs_no_y_fuel_bottom_boundary:
    <<: *dtint
    _content:
    _check:
      - is_string()
  bcs_plenumpressure_plenumpressure_boundary:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  bcs_plenumpressure_plenumpressure_initial_pressure:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  bcs_plenumpressure_plenumpressure_initial_pressure_ifba:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  bcs_plenumpressure_plenumpressure_startup_time:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
  bcs_pressure_coolantpressue_factor:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  bcs_pressure_coolantpressue_function:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  burnup_burnup_rod_ave_lin_pow:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  burnup_burnup_axial_power_profile:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  burnup_burnup_fuel_inner_radius:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  burnup_burnup_fuel_outer_radius:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  burnup_burnup_fuel_volume_ratio:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  burnup_burnup_i_enrich:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  burnup_burnup_num_radial:
    <<: *dtint
    _content:
    _check:
      - is_int()
  burnup_burnup_num_axial:
    <<: *dtint
    _content:
    _check:
      - is_int()
  outputs_console_execute_on:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  coolantchannel_convective_clad_surface_inlet_temperature:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  coolantchannel_convective_clad_surface_inlet_pressure:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  coolantchannel_convective_clad_surface_inlet_massflux:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  coolantchannel_convective_clad_surface_rod_diameter:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  coolantchannel_convective_clad_surface_rod_pitch:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  coolantchannel_convective_clad_surface_linear_heat_rate:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  coolantchannel_convective_clad_surface_axial_power_profile:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  dampers_limitt_max_increment:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  executioner_start_time:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
  executioner_dt:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  executioner_dtmin:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  executioner_dtmax:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  executioner_end_time:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  executioner_num_steps:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
  executioner_l_max_its:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
  executioner_l_tol:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  executioner_nl_max_its:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
  executioner_nl_rel_tol:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  executioner_nl_abs_tol:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  executioner_petsc_options:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  executioner_petsc_options_iname:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  executioner_petsc_options_value:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  executioner_timestepper_type:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  executioner_timestepper_dt:
    <<: *dtdouble
    _content:
    _check:
      - is_string()
  executioner_timestepper_optimal_iterations:
    <<: *dtint
    _content:
    _check:
      - is_string()
  executioner_timestepper_linear_iteration_ratio:
    <<: *dtdouble
    _content:
    _check:
      - is_string()
  executioner_timestepper_time_dt:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  executioner_timestepper_time_t:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  functions_coolant_pressure_ramp_x:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  functions_coolant_pressure_ramp_y:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  functions_axial_peaking_factors_type:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  functions_axial_peaking_factors_value:
    <<: *dtint
    _content:
    _check:
      - is_int()
  functions_axial_peaking_factors_data_file:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  functions_coolant_temperature_type:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  functions_coolant_temperature_data_file:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  functions_coolant_temperature_x:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  functions_coolant_temperature_y:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  functions_linear_heat_rate_profile_x:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  functions_linear_heat_rate_profile_y:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  functions_linear_heat_rate_profile_data_file:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  functions_linear_heat_rate_profile_format:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  functions_linear_heat_rate_profile_scale_factor:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  functions_q_functions:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  globalparams_order:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() first second First Second FIRST SECOND
  globalparams_a_lower:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  globalparams_a_upper:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  globalparams_energy_per_fission:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  materials_clad_density_density:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  materials_clad_solid_mechanics_absolute_tolerance:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  materials_clad_solid_mechanics_relative_tolerance:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  materials_clad_solid_mechanics_stress_free_temperature:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  materials_clad_solid_mechanics_model_primary_creep:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() true false
  materials_clad_solid_mechanics_model_thermal_creep:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() true false
  materials_clad_solid_mechanics_model_irradiation_creep:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() true false
  materials_clad_solid_mechanics_model_irradiation_growth:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() true false
  materials_clad_solid_mechanics_model_thermal_expansion:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() true false
  materials_clad_solid_mechanics_model_elastic_modulus:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() true false
  materials_clad_solid_mechanics_cold_work_factor:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  materials_clad_solid_mechanics_oxygen_concentration:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_geq() 0
  materials_fission_gas_release_end_densification_burnup:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_geq() 0
  materials_fission_gas_release_axial_power_profile:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  materials_fission_gas_release_file_name:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  materials_fission_gas_release_grain_radius:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  materials_fission_gas_release_hydrostatic_stress:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  materials_fission_gas_release_initial_grain_radius:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  materials_fission_gas_release_initial_porosity:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  materials_fission_gas_release_pellet_brittle_zone:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  materials_fission_gas_release_pellet_id:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  materials_fission_gas_release_rod_ave_lin_pow:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  materials_fission_gas_release_total_densification:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_geq() 0
  materials_fuel_thermal_initial_porosity:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  materials_fuel_swelling_total_densification:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  materials_fuel_mech_grain_radius:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  materials_fuel_mech_max_its:
    <<: *dtint
    _content:
    _check:
      - is_int()
  materials_fuel_mech_output_iteration_info:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() true false
  materials_fuel_mech_model_swelling:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() true false
  materials_fuel_mech_name_swelling_model:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  materials_fuel_mech_model_creep:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() true false
  materials_fuel_mech_matpro_youngs_modulus:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() true false
  materials_fuel_relocation_q:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() q linear_heat_generation_rate
  materials_fuel_relocation_relocation_activation1:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  materials_fuel_relocation_burnup_relocation_stop:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  mesh_file:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  mesh_patch_size:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
  mesh_nx_p:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
  mesh_ny_p:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
  mesh_nx_c:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
  mesh_ny_c:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
  mesh_elem_type:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() QUAD4 QUAD8
  mesh_bx_p:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  mesh_clad_bot_gap_height:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  nfuelrod:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
  outputs_file_base:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  pellet_clad_mechanical_penalty:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  pellet_clad_mechanical_tangential_tolerance:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  pellet_clad_mechanical_normal_smoothing_distance:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  pellet_clad_mechanical_model:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() frictionless experimental
  pellet_clad_mechanical_formulation:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() kinematic penalty
  pellet_clad_mechanical_system:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  postprocessors_rod_input_power_scale_factor:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  porosity:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
      - is_lt() 1.0
  executioner_quadrature_order:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() first third fifth seventh FIRST THIRD FIFTH SEVENTH
  thermalcontact_roughness_coef:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  thermalcontact_roughness_fuel:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  thermalcontact_roughness_clad:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  thermalcontact_initial_gas_fractions:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  thermalcontact_tangential_tolerance:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  thermalcontact_quadrature:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() true false TRUE FALSE
  thermalcontact_order:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() first second FIRST SECOND
  fuel_pin_input_file_template:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  non_fuel_pin_input_file_template:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  power_file:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_string(shift)},())
  cycle_xml:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_string(shift)},())
  shuffle_xml:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_string(shift)},())
  only_cycle:
    <<: *dtint
    _content:
    _check:
      - is_int()
      - is_gt() 0
  only_assemblies:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_string(shift)},())
  ramping_time:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_float(shift)},())
  ramping_factor:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_float(shift)},())
  ramp_data_transfers:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
  mesh_type:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() unit_test smeared_pellet
  output_average_axial_values:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
  solve_type:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() standalone tiamat tiamat_inline temp_table STANDALONE TIAMAT TIAMAT_INLINE TEMP_TABLE
  bc_type:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() clad_outer bulk_cool CLAD_OUTER BULK_COOL
  axial_shape:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() midpoint constant MIDPOINT CONSTANT
  fast_flux:
    <<: *dtbool
    _content:
    _check:
      - is_word()
      - in_dictionary() true false
  element_order:
    <<: *dtstring
    _content:
    _check:
      - is_string()
      - in_dictionary() linear quadratic LINEAR QUADRATIC
  variables_temp_initial_condition:
    <<: *dtdouble
    _content:
    _check:
      - is_float()
      - is_gt() 0
  userobjects_pbz_execute_on:
    <<: *dtstring
    _content:
    _check:
      - is_string()
  cycle_outage_time_days:
    <<: *dtlist
    _style: multi-line
    _content:
    _check:
      - fall(sub{is_float(shift)},())

#>
#> \section{Block RUN}
RUN:
#>
#>   {\bf email} list\_of\_emails
#>   \VERAInputTable{
#>     name={email},
#>     type={Character String},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={Default email is the users system email},
#>     valuesapplicable={},
#>     limitations={},
#>     description={Email that is used to inform user of job status.  %
#>        A list of emails can be input by comma seperating the emails.},
#>     notes={}
#>   }
  email:
    <<: *dtstring
    _content: default
    _check:
      - is_string()
#>
#>   {\bf pmem} memory per processor
#>   \VERAInputTable{
#>     name={pmem},
#>     type={Floating-point Number},
#>     need={Optional},
#>     unitsdefault={GB},
#>     unitsother={},
#>     valuedefault={System memory per processor},
#>     valuesapplicable={Greter than 0},
#>     limitations={},
#>     description={Memory per processor},
#>     notes={}
#>   }
  pmem:
    <<: *dtstring
    _content: default
    _check:
      - is_float()
      - is_gt() 0
#>
#>   {\bf ppn} processors per node
#>   \VERAInputTable{
#>     name={ppn},
#>     type={Integer},
#>     need={Optional},
#>     unitsdefault={},
#>     unitsother={},
#>     valuedefault={System processors per node},
#>     valuesapplicable={Greater than 0},
#>     limitations={},
#>     description={Number of processors that will be used per node},
#>     notes={}
#>   }
  ppn:
    <<: *dtstring
    _content: default
    _check:
      - is_int()
      - is_gt() 0
#>
#>   {\bf walltime} maximum expected runtime
#>   \VERAInputTable{
#>     name={walltime},
#>     type={Floating-point Number},
#>     need={Optional},
#>     unitsdefault={hours},
#>     unitsother={},
#>     valuedefault={24 hours},
#>     valuesapplicable={},
#>     limitations={},
#>     description={The walltime that is used for pbs submission},
#>     notes={}
#>   }
  walltime:
    <<: *dtstring
    _content: default
    _check:
      - is_float()
      - is_gt() 0
